<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Bamboo: Using Bamboo</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Bamboo&#160;<span id="projectnumber">v1.1</span></div>
   <div id="projectbrief">Process Orientated Game Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Using Bamboo </div>  </div>
</div>
<div class="contents">
<div class="textblock"><p>In this Section are a few sub sections:</p>
<ol type="1">
<li><a class="el" href="_using_engine_page.html#MainLoop">Overview of Bamboo</a></li>
<li><a class="el" href="_using_engine_page.html#KernelPage">The Kernel</a></li>
<li><a class="el" href="_using_engine_page.html#ProcessObjectsPage">How to use Process Objects</a></li>
<li><a class="el" href="_using_engine_page.html#RenderObjectsPage">How to use Render Objects</a></li>
<li><a class="el" href="_using_engine_page.html#FilesAccessPage">Loading and Accessing Files</a></li>
<li><a class="el" href="_using_engine_page.html#InputsPage">Accessing User Inputs</a></li>
<li><a class="el" href="_using_engine_page.html#AudioPage">Using the Audio System</a></li>
<li><a class="el" href="_using_engine_page.html#SignalsPage">Signals and Flags</a></li>
<li><a class="el" href="_using_engine_page.html#CollisionsPage">Detecting Collisions</a></li>
<li><a class="el" href="_using_engine_page.html#RenderNodesPage">Creating Local Co-ordinate systems</a></li>
<li><a class="el" href="_using_engine_page.html#MultipleCamerasViewports">Multiple Cameras and Viewport Control</a></li>
<li><a class="el" href="_using_engine_page.html#IMFGenerationPage">IMF File Generation and Usage</a></li>
</ol>
<h2><a class="anchor" id="MainLoop"></a>
Overview of Bamboo</h2>
<p>WTBamboo.h</p>
<p>Bamboo is based on a Process / Renderable Object mentality. Process' are classes with behavioural code which tell them how to behave. They take inputs from the OS, signal other process' and tell Renderable objects how to display. Once a Process is written, the user should create a new instance. The system will record the information add it to the system and make the process enact it's behaviour, with no further input form the user (Fire and Forget). This way many similar objects can be created easily once the behavioural code is written. Render Objects should not have any behavioural code and are entirely directed by Process'. The Process' are controlled by <a class="el" href="classc_kernel.html" title="Kernel Object. Handles Processes. Tracks, runs and deletes current processes. Has complete control ov...">cKernel</a> which will track and update all the process'. Render Objects actually display on the screen. They are moved around in 3D space and <a class="el" href="classc_camera.html" title="This class will control the rendering of the render tree. It will handle all the render objects and h...">cCamera</a> renders them to the screen. Collision Objects must be handed a Render Object at startup, which they will follow and determine collisions with other Collision Objects. Files are loaded by the FileHandler and can be asked to provide media data for Render Objects and Collision Objects. Lighting effects are controlled by the LightHandler. <br/>
 In Bamboo programs the ESC key is automatically assigned to exit the program. Any Bamboo program can be quit by pressing ESC or clicking the close button in the top right of the window.</p>
<p>The Main Loop: In the template there is the main loop. Create a new project and look at the file main.cpp. In the file you will see the following code: </p>
<div class="fragment"><pre class="fragment"> <span class="comment">//Using @EngineName in Windows</span>
<span class="preprocessor"> #include &lt;WTBamboo.h&gt;</span>

 <span class="comment">//Windows Specific Main function. This will give access to inputs and windows signals.</span>
 <span class="keywordtype">int</span> WINAPI WinMain (HINSTANCE hInstance,
                    HINSTANCE hPrevInstance,
                    LPSTR lpCmdLine,
                    <span class="keywordtype">int</span> iCmdShow)
 {
 <span class="comment">//This will Start @EngineName with cCore as the Core Process.</span>
 <span class="comment">//cUserSettings is the class which will initialise the Engine Settings.</span>
 <span class="comment">//hInstance is a Windows hook to allow creating a new window.</span>
 <span class="keywordflow">return</span> _START_PROGRAM(cCore,cUserSettings,hInstance);
};
*
</pre></div> <div class="fragment"><pre class="fragment"> <span class="comment">//Using @EngineName in Linux</span>
<span class="preprocessor"> #include &lt;WTBamboo.h&gt;</span>

 <span class="comment">//C++ standard main function.</span>
 <span class="keywordtype">int</span> main ()
 {
 <span class="comment">//This will Start @EngineName with cCore as the Core Process.</span>
 <span class="comment">//cUserSettings is the class which will initialise the Engine Settings.</span>
  <span class="keywordflow">return</span> _START_PROGRAM(cCore,cUserSettings);
 };
*
</pre></div><p>Main Loop Explanation: This will call the main function which will initialise the various components of the system. First_Process_Type must be a class type which inherits <a class="el" href="classc_process.html" title="This is the base code for a process. This will automatically create a new process. It will hand itself to cKernel to be processed every frame. Any Processes created by the user should inherit this type to be handled by cKernel automatically. Initialisation code should go in the constructor of the user type. Linking to cKernel is performed automatically by cProcess. Update code should go in the function Run(). Coed performed when a process is killed should go in the function Stop(). NOT the destructor. Code to handle Sleeping and Waking signals should go in OnSleep() and OnWake(). Code to handle interaction of two processes should go in either processes UserSignal() function.">cProcess</a> and should be the process that initialises and creates all the other processes required for the game. User_Settings_Type must be a class type which inherits cSettings. The virtual function UserSettings() in the derived class should set all the variables the user wishes to define. If the User does not wish to define ANY settings, use cSettings here and the defaults will be used. hInstance is a Windows only variable which is passed from the operating system to the WinMain function. Use the first HINSTANCE Passed to the function.<br/>
 First _START_PROGRAM will set the settings for the game to use.<br/>
 Then it will initialise the various components of the engine.<br/>
 It will create an instance of the class type First_Process_Type which should initilise the game and create other processes to start the game.<br/>
 While there are processes alive (and the system has not received an exit signal) the system will continue to cycle.<br/>
 As the system exit, it will clear data, close links to devices and hardware and return a suitable exit signal for the Operating system. This should be returned from the funciton main().<br/>
</p>
<h2><a class="anchor" id="KernelPage"></a>
The Kernel</h2>
<p>WTKernel.h</p>
<p>Using the kernel system by William Thorley</p>
<p>The Kernel does not need to be understood by the user, but is refered to later so a brief description will be given here. The Kernel owns and controls all the processes in the program. The kernel will create itself as soon as any Process is created. It will automatically grab any process as soon as it is created and can sort their run order. A Pointer to the <a class="el" href="classc_kernel.html" title="Kernel Object. Handles Processes. Tracks, runs and deletes current processes. Has complete control ov...">cKernel</a> can always be found by calling the macro _KERNEL (<a class="el" href="classc_kernel.html#a1d873e903cf2bccceee0a68bd9d4dd01" title="Function which returns current Kernel Instance. Will Create a new instance if one does not already ex...">cKernel::Instance()</a>). If this function is called and there is no <a class="el" href="classc_kernel.html" title="Kernel Object. Handles Processes. Tracks, runs and deletes current processes. Has complete control ov...">cKernel</a>, the function will create one. The Constructor is private, so there can be only one <a class="el" href="classc_kernel.html" title="Kernel Object. Handles Processes. Tracks, runs and deletes current processes. Has complete control ov...">cKernel</a>. The Kernel is entirely automatic and should require no inputs from the user. However it can supply useful information and functionality to the user. cKernel::KillAll(): Calling cKernel::KillAll() will kill every running process. This will cause Update() to exit, and traditionally end the program. However it is possible to cKernel::KillAll(), then create a new core process, and call Update() again, thereby ‘restarting’ the program.</p>
<p>_FIND_PROCESS(TYPE) Calling _FIND_PROCESS() will automatically search the <a class="el" href="classc_kernel.html" title="Kernel Object. Handles Processes. Tracks, runs and deletes current processes. Has complete control ov...">cKernel</a> for any processes of class type TYPE. It will return a pointer to the next process of class type TYPE everytime it is called. When there are no more processes of class type TYPE it will return 0. </p>
<h2><a class="anchor" id="FirstProcessPage"></a>
Your First Process</h2>
<p>WTcProcess.h</p>
<p>The First Process is exactly the same as every other process. i.e. it must inherit <a class="el" href="classc_process.html" title="This is the base code for a process. This will automatically create a new process. It will hand itself to cKernel to be processed every frame. Any Processes created by the user should inherit this type to be handled by cKernel automatically. Initialisation code should go in the constructor of the user type. Linking to cKernel is performed automatically by cProcess. Update code should go in the function Run(). Coed performed when a process is killed should go in the function Stop(). NOT the destructor. Code to handle Sleeping and Waking signals should go in OnSleep() and OnWake(). Code to handle interaction of two processes should go in either processes UserSignal() function.">cProcess</a>. What is special about the Process passed to the _START_PROGRAM() call is that it is the automatically called when the Kernel is initialized. This means that the constructor for the first process is the initialization code for the entire program. Usually the process’ which will form the program are started here as well as loading files for the system. For these examples I wil call the class cCore.</p>
<p>This shows the declaration for cCore. Using _PROCESS(Type) is the same as calling class Type : public <a class="el" href="classc_process.html" title="This is the base code for a process. This will automatically create a new process. It will hand itself to cKernel to be processed every frame. Any Processes created by the user should inherit this type to be handled by cKernel automatically. Initialisation code should go in the constructor of the user type. Linking to cKernel is performed automatically by cProcess. Update code should go in the function Run(). Coed performed when a process is killed should go in the function Stop(). NOT the destructor. Code to handle Sleeping and Waking signals should go in OnSleep() and OnWake(). Code to handle interaction of two processes should go in either processes UserSignal() function.">cProcess</a> to inherit <a class="el" href="classc_process.html" title="This is the base code for a process. This will automatically create a new process. It will hand itself to cKernel to be processed every frame. Any Processes created by the user should inherit this type to be handled by cKernel automatically. Initialisation code should go in the constructor of the user type. Linking to cKernel is performed automatically by cProcess. Update code should go in the function Run(). Coed performed when a process is killed should go in the function Stop(). NOT the destructor. Code to handle Sleeping and Waking signals should go in OnSleep() and OnWake(). Code to handle interaction of two processes should go in either processes UserSignal() function.">cProcess</a>. Declaration: </p>
<div class="fragment"><pre class="fragment"> _PROCESS(cCore)
 {
  <span class="keyword">public</span>:
  cCore();

  <span class="keywordtype">void</span> Run();

  <span class="keywordtype">void</span> Stop();

 };
</pre></div><p>cCore(): This shows the constructor for cCore. As it is the first object it will load media for the rest of the program and kick off the other processes. </p>
<div class="fragment"><pre class="fragment"> cCore::cCore()
 {
 <span class="comment">//Load IMF Files into memory.</span>
  _LOAD_FILE(<span class="stringliteral">&quot;../src/User/Models/AShipModel.imf&quot;</span>);
  _LOAD_FILE(<span class="stringliteral">&quot;../src/User/Models/StartShip.imf&quot;</span>);
  _LOAD_FILE(<span class="stringliteral">&quot;../src/User/Textures/ATexture.imf&quot;</span>);
  _LOAD_FILE(<span class="stringliteral">&quot;../src/User/CollisionObjects/ACollision.imf&quot;</span>);
  _LOAD_FILE(<span class="stringliteral">&quot;../src/User/Objects/AIMFFileWithSeveralComponents.imf&quot;</span>);

 <span class="comment">// Setup the camera.</span>
  _CAMERA-&gt;Far(1000.0f);
  _CAMERA-&gt;Frustum();

 <span class="comment">//Create a new process and a renderable object.</span>
  mpProcessPointer=_CREATE(MyFirstProcess());
  mpRenderObjectPointer=_CREATE(MyFirstRenderObject());

 }
</pre></div><p>Run(): Run() is run once every frame as long as cCore is alive and controls the entire program. The Run() function should is explicity designed to be re-written by the user to give each <a class="el" href="classc_process.html" title="This is the base code for a process. This will automatically create a new process. It will hand itself to cKernel to be processed every frame. Any Processes created by the user should inherit this type to be handled by cKernel automatically. Initialisation code should go in the constructor of the user type. Linking to cKernel is performed automatically by cProcess. Update code should go in the function Run(). Coed performed when a process is killed should go in the function Stop(). NOT the destructor. Code to handle Sleeping and Waking signals should go in OnSleep() and OnWake(). Code to handle interaction of two processes should go in either processes UserSignal() function.">cProcess</a> class their functionality. This Code can be seen as the behaviour that the process should follow. It should rotate and position the Process' Renderobjects, send signals, receive inputs, anything the Process may want to do as part of it's behaviour. The function cCore::Run() can be used like any other process, but is usually used to oversee the running of the program. </p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> cCore::Run()
 {

  <span class="keywordflow">if</span>(KEY_SPACE) _CAMERA-&gt;Far(10.0f);
   <span class="keywordflow">else</span> _CAMERA-&gt;Far(1000.0f);
  _CAMERA-&gt;Frustum();

  _CREATE(AnotherProcess());
  mpRenderObjectPointer-&gt;Advance(0.1f);

 }
</pre></div><p>Stop(): This is called whenever the cCore Process is Killed. This will only activate if the process was alive and is now dead. This should be used to kill or transfer control of Render Objects that are owned by this process, or unload files that are no longer used.</p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> cCore::Stop()
 {
 _KILL(mpRenderObjectPointer);
 mpProcessPointer_SIGNAL(_S_SLEEP);
 }
</pre></div><p>OnSleep(): This is called whenever the cCore Process is made to Sleep. This will only activate if the process was awake and is now asleep. This is generally used to sleep Render Objects that are owned by this process.</p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> cCore::OnSleep()
 {
 mpRenderObjectPointer-&gt;Signal(_S_SLEEP);
 }
</pre></div><p>OnWake(): This is called whenever the cCore Process is made to Wake. This will only activate if the process was asleep and is now awake. This is generally used to wake Render Objects that were slept when cCore was sent to sleep.</p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> cCore::OnWake()
 {
 mpRenderObjectPointer-&gt;Signal(_S_WAKE);
 }
</pre></div><h2><a class="anchor" id="ProcessObjectsPage"></a>
How to use Process Objects</h2>
<p>WTcProcess.h</p>
<p>Using William Thorley’s Process Handler System</p>
<p>When properly implemented the process handler automatically links and runs all processes. A process must inherit <a class="el" href="classc_process.html" title="This is the base code for a process. This will automatically create a new process. It will hand itself to cKernel to be processed every frame. Any Processes created by the user should inherit this type to be handled by cKernel automatically. Initialisation code should go in the constructor of the user type. Linking to cKernel is performed automatically by cProcess. Update code should go in the function Run(). Coed performed when a process is killed should go in the function Stop(). NOT the destructor. Code to handle Sleeping and Waking signals should go in OnSleep() and OnWake(). Code to handle interaction of two processes should go in either processes UserSignal() function.">cProcess</a>. It must also define the virtual function Run() a process without a Run() function is useless, and will be deleted during the frame it is created.</p>
<p>Declaring a new process class called player: </p>
<div class="fragment"><pre class="fragment"> <span class="comment">//This is the same as _PROCESS(player)</span>
 <span class="keyword">class </span>player : <span class="keyword">public</span> <a class="code" href="classc_process.html" title="This is the base code for a process. This will automatically create a new process. It will hand itself to cKernel to be processed every frame. Any Processes created by the user should inherit this type to be handled by cKernel automatically. Initialisation code should go in the constructor of the user type. Linking to cKernel is performed automatically by cProcess. Update code should go in the function Run(). Coed performed when a process is killed should go in the function Stop(). NOT the destructor. Code to handle Sleeping and Waking signals should go in OnSleep() and OnWake(). Code to handle interaction of two processes should go in either processes UserSignal() function.">cProcess</a>
 {
 <span class="keyword">public</span> :
 <span class="keywordtype">void</span> <a class="code" href="classc_process.html#a3e0fab4ccc0a8fb065d50eb88b6a0dd5" title="This Function stores the code which will update this process by a single frame. This user defined fun...">Run</a>();
 };
</pre></div><p>void <a class="el" href="classc_process.html#a3e0fab4ccc0a8fb065d50eb88b6a0dd5" title="This Function stores the code which will update this process by a single frame. This user defined fun...">cProcess::Run()</a>; The function Run() is a virtual function already defined. This function is called every time the process must run its code (usually once a frame). The code that defines how the process acts goes in Run().</p>
<p>Creating a Process: Call the macro _CREATE(Type); This will return a pointer to the new process of type Type. </p>
<div class="fragment"><pre class="fragment"> player *mpNewProcessPointer;
 NewProcessPointer=_CREATE(player());
 _CREATE(AnotherProcess(Argument1,Argument2));
</pre></div><p>Killing a Process: Process' must not be destroyed by deleting the process. Processes can be be deleted either by calling the macro _KILL(); or by calling the Function Signal(SIGNAL lsFlags) with the flag _S_KILL. if _KILL() is called without a pointer it will automatically use the pointer this. Process' will not be destroyed when the signal is sent, they will be deacticated, but the memory will remain allocated until <a class="el" href="classc_kernel.html" title="Kernel Object. Handles Processes. Tracks, runs and deletes current processes. Has complete control ov...">cKernel</a> reaches the correct stage to delete the object. Objects can remain allocated into the next frame, but not the frame after that. Both pieces of following code have the same effect. The Process pointed to by mpPointerToAnotherProcess is Killed and then this process is killed. </p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> <a class="code" href="classc_process.html#a3e0fab4ccc0a8fb065d50eb88b6a0dd5" title="This Function stores the code which will update this process by a single frame. This user defined fun...">player::Run</a>()
 {

 <span class="keywordflow">if</span>(KEY_k)
 {
 mpPointerToAnotherProcess-&gt;Signal(_S_KILL);
 _KILL(<span class="keyword">this</span>);
 }

 }
</pre></div><div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> <a class="code" href="classc_process.html#a3e0fab4ccc0a8fb065d50eb88b6a0dd5" title="This Function stores the code which will update this process by a single frame. This user defined fun...">player::Run</a>()
 {

 <span class="keywordflow">if</span>(KEY_k)
        {
         _KILL(mpPointerToAnotherProcess);
         _KILL();
        }

 }
</pre></div><p>Sleeping a Process: A Process can be sent to sleep by calling the <a class="el" href="classc_signal.html#a545074be1da41d00050bed3cd2fb2305" title="This is the function that will handle a system signal. Possible signals to be passed in are _S_SLEEP...">cSignal::Signal(SIGNAL lsFlags)</a> function with the value _S_SLEEP. Sleeping a process leaves the process in the process list, but stops the Run() function being called every frame. This allows the Signal(SIGNAL lsFlags) function to be used to return it to ‘active duty’. The memory will remain allocated. Sending repeated Sleep calls to a process will not affect the process or the stability of the system, the Process will remain asleep.</p>
<p>Waking a Process: A Process can be awakend by calling the <a class="el" href="classc_signal.html#a545074be1da41d00050bed3cd2fb2305" title="This is the function that will handle a system signal. Possible signals to be passed in are _S_SLEEP...">cSignal::Signal(SIGNAL lsFlags)</a> function with the value _S_WAKE. Sending repeated Waking calls to a process will not affect the process or the stability of the system, the Process will remain awake. </p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> <a class="code" href="classc_process.html#a3e0fab4ccc0a8fb065d50eb88b6a0dd5" title="This Function stores the code which will update this process by a single frame. This user defined fun...">player::Run</a>()
 {

 <span class="keywordflow">if</span>(KEY_s) mpPointerToAnotherProcess-&gt;Signal(_S_SLEEP);
 <span class="keywordflow">if</span>(KEY_w) mpPointerToAnotherProcess-&gt;Signal(_S_WAKE);

 }
</pre></div><p>Removing a Process: A Process can be killed by the <a class="el" href="classc_kernel.html" title="Kernel Object. Handles Processes. Tracks, runs and deletes current processes. Has complete control ov...">cKernel</a> object. Calling the cKernel::Remove() function will kill the process and free the memory. This must not be done to the currently running process or the system may crash. Use on the current process at your peril. The pointer is to the cLinkedNode&lt;vProcess&gt; which owns this process. Each Process has a pointer (mpNode) to its cLinkedNode&lt;vProcess&gt;. </p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> <a class="code" href="classc_process.html#a3e0fab4ccc0a8fb065d50eb88b6a0dd5" title="This Function stores the code which will update this process by a single frame. This user defined fun...">player::Run</a>()
 {

 <span class="keywordflow">if</span>(KEY_k) _KERNEL-&gt;Remove(mpPointerToAProcessesNode);

 }
</pre></div> <h2><a class="anchor" id="RenderObjectsPage"></a>
How to use Render Objects</h2>
<p>WTcRenderObject.h</p>
<p>All Render Objects are inherited from class vRenderObject, through class <a class="el" href="classc_render_object.html" title="This class contains the base code for all renderable objects. Any renderable object should inherit th...">cRenderObject</a>. The object also Inherits the class <a class="el" href="classc_matrix4.html" title="this is a standard 4x4 translation matrix for objects. This is a standard 4x4 translation matrix for ...">cMatrix4</a>. This is a 3D Translation class, and can handle 2D rotations (about X axis), 3D rotations, 3D Translations and 3D scaling. All <a class="el" href="classc_matrix4.html" title="this is a standard 4x4 translation matrix for objects. This is a standard 4x4 translation matrix for ...">cMatrix4</a> functions can be called from a pointer to any Render Object and will move the <a class="el" href="classc_render_object.html" title="This class contains the base code for all renderable objects. Any renderable object should inherit th...">cRenderObject</a> based on the <a class="el" href="classc_matrix4.html" title="this is a standard 4x4 translation matrix for objects. This is a standard 4x4 translation matrix for ...">cMatrix4</a> function called. Render Objects must be assigned a Shader to render to screen. Due to depreciation of OpenGL Functionality shaders are required to position an object in 3D space. All objects must be given a <a class="el" href="classc_shader_program.html" title="A cShaderProgram() is a series of cShader() objects compiled into a program. cShaderProgram is a cFil...">cShaderProgram</a> to render. Creating RenderObjects: cRenderObjects can be created using the _CREATE macro as per a Process. This will return a pointer to the RenderObject. </p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> <a class="code" href="classc_process.html#a3e0fab4ccc0a8fb065d50eb88b6a0dd5" title="This Function stores the code which will update this process by a single frame. This user defined fun...">player::Run</a>()
 {
        mpHull=_CREATE(<a class="code" href="classc_model.html" title="A standard Textured Model renderable object.">cModel</a>(mpShipNode));
        mpHull-&gt;Mesh(<span class="stringliteral">&quot;Mesh&quot;</span>);
        mpHull-&gt;Texture(<span class="stringliteral">&quot;Texture&quot;</span>);
        mpHull-&gt;Shader(<span class="stringliteral">&quot;TexturingProgram&quot;</span>);
 }
 *
</pre></div><p>Currently there are lots of Render Objects:</p>
<p>class <a class="el" href="classc_model.html" title="A standard Textured Model renderable object.">cModel</a>; <br/>
 class cLandscape; <br/>
 class cBeamMesh; <br/>
 class cImage; <br/>
 class cTextureText; <br/>
 class <a class="el" href="classc_line.html" title="A standard renderable Line object.">cLine</a>; <br/>
 class cParticle; <br/>
 class cParticleGroup; <br/>
 class cParticleHandler; <br/>
 class <a class="el" href="classc_point.html" title="A Renderable object for rendering single points.">cPoint</a>; <br/>
 class cButton; <br/>
 class cTextButton; <br/>
 <br/>
 There are also Render Nodes. These do not display on the screen bu manipulate the position of other objects. Essentially they create new co-ordinate systems. This allows objects to be positioned and rotated to other objects or points in space. This allows the 'gluing' or 'linking' of objects together. This allows the creating of models with limbs, or turrets etc. <br/>
 class <a class="el" href="classc_render_node.html" title="This is a dynamic render tree branch. This class stores a dynamic list of cRenderObjects called mpObj...">cRenderNode</a>; <br/>
 class cNodeList; <br/>
 <br/>
 See the relevant documentation for each for how to use them. <br/>
 <br/>
 The Renderable Object allows the user to develop their own Renderable Objects and links them to the renderer. A Renderable object must inherit <a class="el" href="classc_render_object.html" title="This class contains the base code for all renderable objects. Any renderable object should inherit th...">cRenderObject</a> and must also define the virtual function Render(), This will be called every time the renderable object needs to be rendered. It should also define all empty virtual functions in vRenderObject and <a class="el" href="classc_render_object.html" title="This class contains the base code for all renderable objects. Any renderable object should inherit th...">cRenderObject</a>.</p>
<h2><a class="anchor" id="MultiTexturing"></a>
Texturing Objects</h2>
<p>In the latest release Multiple Textures have been implemented. This means that you can send, a texture, a bump map and a lighting map to a single model and produce much more complicated shader effects. <br/>
 For those who don't want a detailed overview.</p>
<ul>
<li>Your shaders should call their uniform sampler2D variables "Texture0" "Texture1" "Texture2" etc.</li>
<li>In the class cUserSettings set the variable WT_TEXTURE_NUMBER_ALLOWED to the number of simultaneous textures required. This is 2 by default.</li>
<li>An Object can only have textures applied to it once it has a shader. Use the function <a class="el" href="classc_render_object.html#abd47a58de22adfe1e9a1970f66a2f4cd" title="Will set the shader this object will use.">cRenderObject::Shader(cShaderProgram*)</a>.</li>
<li>Use the function <a class="el" href="classc_render_object.html#ad45b379f57731d803f7a52e58d91d3aa">cRenderObject::AddTexture(cTexture*)</a> to add a texture to a <a class="el" href="classc_render_object.html" title="This class contains the base code for all renderable objects. Any renderable object should inherit th...">cRenderObject</a>. They will be added to the object and placed in slots in the order they are added. <br/>
 Textures are applied to Renderable objects using the function AddTexture(string,cTexture*). This function will add the Texture pointer to the Texture slot with the name matching lsTextureSlot. Alternatively AddTexture(cTexture*) or AddTexture(string) can be used. This will add the texture to the next free texture slot in the shader named "Texture0" "Texture1" "Texture2" etc. <br/>
 Declaring Textures in Fragment Shaders: Multitexturing in shaders is controlled using uniform sampler types: <div class="fragment"><pre class="fragment"> uniform sampler2D Texture0;
</pre></div> This takes a 2D Texture and names it Texture0. By default Bamboo shaders use the names Texture0, Texture1 ,Texture2 etc. If you use different names for your texture samplers they will need to be linked to their textures using AddTexture(string,cTexture*). <br/>
</li>
</ul>
<h2><a class="anchor" id="FilesAccessPage"></a>
Loading and Accessing Files</h2>
<p>WTcFile.h</p>
<p>The Filehandler is an automatic system for controlling files loaded in Bamboo. All files should be of type IMF, though others can be loaded. When a file is loaded it is automatically linked into the system. This allows any process to access any loaded file. All Objects (blocks within IMF Files) are given a Reference (a character string) to allow them to be easily identified. And in the event of an OS clearing data (for instance Windows clearing Textures on Minimize) the file handler will automatically reload all the files. IMF Files can be created using the IMF Handler. This allows other files to be loaded and compiled into IMF Files. IMF Files are designed to not require any processing to speed loading times. It also allows the system to use object references which makes accessing components much much easier.</p>
<p>To create a new File Class and make it use the file handler, have it inherit <a class="el" href="classc_file.html" title="This is the base code for files to be loaded from a hdd. Any file object loaded from a hddvshould inh...">cFile</a>, This will require #include “WTcFile.h”. To load a new file use the macro _LOAD_FILE(FileName).</p>
<p>IMF Files contain many types of data:</p>
<p>Models Textures Fonts Model Trees Reference Lists Shaders Shader Programs Collision Objects Landscape Models</p>
<p>Useful Macros:</p>
<p>These will return a pointer to the file of the appropriate type with the Test Identifier 'Reference'. The files are checked for type, however giving files the same text identifier is bad practice. _GET_TEXTURE_FILE(Reference) _GET_MESH_FILE(Reference) _GET_FONT_FILE(Reference) _GET_AUDIO_FILE(Reference) _GET_COLLISION_MESH_FILE(Reference) _GET_LANDSCAPE_FILE(Reference) _GET_COMPOUND_COLLISION_FILE(Reference) _GET_MODELLIST_FILE(Reference) _GET_FILE(FileType,FileName) Will allow you to specify a type for the file and a text identifier reference. This should only be used for used defined File types.</p>
<p>The default linking code is of the Form <a class="el" href="classc_file_handler.html#a03de3fbc79a44ef92ca36373743a92fd" title="This will return a pointer to the current cFileHandler. If there is no current instance it will creat...">cFileHandler::Instance()</a>-&gt;File&lt;FileType&gt;(FileName). The Macros above automatically select the appropriate Internal class. </p>
<h2><a class="anchor" id="InputsPage"></a>
Accessing User Inputs</h2>
<p>There are two main types on input. Mouse inputs and Key inputs. Both are updated every frame and buffered until the next frame. This means that a key press or mouse position will be consistent throughout the entire frame. THe inputs re recieved as interupts so will be recieved in line with the OS. Key states are boolean and can be accessed using the macro _KEY(Key Identifier). A list of Key Identifiers can be found on page <a class="el" href="_reference_lists.html#KeyIdentifiersList">Key Identifiers</a>. True is key pressed, false is key not pressed.<br/>
 The Key Identifiers are unsigned integer values and can be handled as such, this means they can be passed to functions and processes as unsigned integer values. They can also be manipulated mathematically if the actual values they hold are know.<br/>
 <br/>
 The Mouse can be accessed using the macro _MOUSE() which is a pointer to the <a class="el" href="classc_mouse.html" title="This will store all the input data for a single mouse. It also controls the interpretation of the inp...">cMouse</a> Object. The mouse has three buttons (for now) left, right and middle, because that is enough for most people. Like keys these are boolean values, with true for pressed and false for not pressed. The mouse also has x,y and z which are the cursor position in pixels from the window position 0,0. Finally the mouse has xs and ys which is the amount the cursor has moved (in pixels) since the last frame.<br/>
 <br/>
 The macro _MOUSE() is of the form <a class="el" href="classc_event_handler.html#a8cf5519e1f3c5f6a6f79f9da75fb2750" title="This will return a pointer to the current cEventhandler instance. If there is no instance it will cre...">cEventHandler::Instance()</a>-&gt;Mouse()<br/>
 The macro _KEY() is of the form <a class="el" href="classc_event_handler.html#a8cf5519e1f3c5f6a6f79f9da75fb2750" title="This will return a pointer to the current cEventhandler instance. If there is no instance it will cre...">cEventHandler::Instance()</a>-&gt;Key.GetKey(_CHOSEN_KEY)<br/>
 </p>
<h2><a class="anchor" id="AudioPage"></a>
Using the Audio System</h2>
<p>The class <a class="el" href="classc_audio_object.html" title="This class will allow a sound to be played. This class will link an audio source and a buffer...">cAudioObject</a> are used to play sounds from the sound card. Audio files are included into IMF Files and loaded like any other IMF file. A Sound file is passed to the buffer and played with the Play() command. When the sound is played it will take up a channel on the sound card. A Audio Media File can be accessed using the _GET_AUDIO_FILE() Macro like anyother type of media.</p>
<div class="fragment"><pre class="fragment"> <span class="comment">//Create a new cAudioObject.</span>
 <a class="code" href="classc_audio_object.html" title="This class will allow a sound to be played. This class will link an audio source and a buffer...">cAudioObject</a> *mAO;

 <span class="comment">// Load an IMF file with some audio media.</span>
 _LOAD_FILE(<span class="stringliteral">&quot;./src/User/Audio/wave1.imf&quot;</span>);

 <span class="comment">//Create the cAudioObject to buffer the sound file in.</span>
 mAO = <span class="keyword">new</span> <a class="code" href="classc_audio_object.html" title="This class will allow a sound to be played. This class will link an audio source and a buffer...">cAudioObject</a>;

 <span class="comment">//Load the sound file into the buffer</span>
 mAO-&gt;SetBuffer( <span class="stringliteral">&quot;SoundReference&quot;</span> );

 <span class="comment">//Play the sound</span>
 mAO-&gt;<a class="code" href="classc_audio_object.html#a2e7c8dc824eef10006f0f1c2824f10cd" title="This will play a sound through the OpenAL source from the buffer.">Play</a>();
</pre></div><h2><a class="anchor" id="SignalsPage"></a>
Signals and Flags</h2>
<p>There are a range of Signal macros which allow you to send signals to other processes. </p>
<div class="fragment"><pre class="fragment"> <span class="keywordflow">if</span>(KEY_SPACE) _SLEEP_THIS();
 <a class="code" href="classc_process.html" title="This is the base code for a process. This will automatically create a new process. It will hand itself to cKernel to be processed every frame. Any Processes created by the user should inherit this type to be handled by cKernel automatically. Initialisation code should go in the constructor of the user type. Linking to cKernel is performed automatically by cProcess. Update code should go in the function Run(). Coed performed when a process is killed should go in the function Stop(). NOT the destructor. Code to handle Sleeping and Waking signals should go in OnSleep() and OnWake(). Code to handle interaction of two processes should go in either processes UserSignal() function.">cProcess</a> *OtherProcess;
 OtherProcess=_FIND_PROCESS(cChildProcess);
 _KILL(OtherProcess);
</pre></div><p> <br/>
 <br/>
 List of macros: _KILL(PROCESS) : Will kill the object pointed to by PROCESS. _SLEEP(PROCESS) : Will sleep the object pointed to by PROCESS. _WAKE(PROCESS) : Will wake the object pointed to by PROCESS. _KILL_THIS() : Will kill this object. Code after this will still be run, once this frame. The command return will allow the user to exit the object without running further code. _SLEEP_THIS() : Will sleep this object. Code after this will still be run, once this frame. The command return will allow the user to exit the object without running further code. _WAKE_THIS() : Will never have an effect. (As the code will not run if this object is asleep and there is no waking to be done if the process is awake).</p>
<p>You can send your own signals between processes by defining the function <a class="el" href="classc_user_signal.html#a2f7ada3ca4ee80e2082e12a97b450221" title="Function to handle user specified signals. SIGNAL is an unsigned integer and lpData allows additional...">cUserSignal::UserSignal(SIGNAL lsSignal,void * lpData)</a> in your process class. This function is empty and virtual so This function is entirely user defined which means you can use your own flags to signal different actions for different processes. The void pointer allows you to send any additional information you may want. UserSignal() is a part of <a class="el" href="classc_process.html" title="This is the base code for a process. This will automatically create a new process. It will hand itself to cKernel to be processed every frame. Any Processes created by the user should inherit this type to be handled by cKernel automatically. Initialisation code should go in the constructor of the user type. Linking to cKernel is performed automatically by cProcess. Update code should go in the function Run(). Coed performed when a process is killed should go in the function Stop(). NOT the destructor. Code to handle Sleeping and Waking signals should go in OnSleep() and OnWake(). Code to handle interaction of two processes should go in either processes UserSignal() function.">cProcess</a> so any <a class="el" href="classc_process.html" title="This is the base code for a process. This will automatically create a new process. It will hand itself to cKernel to be processed every frame. Any Processes created by the user should inherit this type to be handled by cKernel automatically. Initialisation code should go in the constructor of the user type. Linking to cKernel is performed automatically by cProcess. Update code should go in the function Run(). Coed performed when a process is killed should go in the function Stop(). NOT the destructor. Code to handle Sleeping and Waking signals should go in OnSleep() and OnWake(). Code to handle interaction of two processes should go in either processes UserSignal() function.">cProcess</a> pointer can use it and will select the version of the function in the derived class. <br/>
</p>
<p>For Advanced Programmers: <br/>
 The macros above actually link to the inherited function Signal(uint8) in <a class="el" href="classc_signal.html" title="Class for handling Signals sent between objects (cProcess, cRenderObject, cCollisionObject). Allows the user to wake, sleep and kill objects. For cProcess (while cParentStack is enabled) also allows signals to be sent to a process that will recursively affect all the children of that process. Possible signals to be passed in are _S_SLEEP,_S_WAKE,_S_KILL,_S_SLEEP_TREE, _S_WAKE_TREE,_S_KILL_TREE User Specified Signals are controlled by the class cUserSignal.">cSignal</a>. This takes the following flags to have the desired effects. This will activate cSignal::AdditionalKillFunctionality(), cSignal::AdditionalSleepFunctionality(), cSignal::AdditionalWakeFunctionality() when Killed, slept of woken.</p>
<ul>
<li>_S_KILL<ul>
<li>Kill the process. It will be deactivated and no longer run. Once it is safe to do so, the Kernel will delete the object. This techincally Sleeps the object (so it won't run) then deletes the object once it is handled.</li>
</ul>
</li>
<li>_S_SLEEP<ul>
<li>Sleep the process. It will be deactivated, but will not get deleted. The Process will continue to exist, but will not run. Objects this Process controls will remain and can be controlled from other processes.</li>
</ul>
</li>
<li>_S_WAKE<ul>
<li>Wake the Process. A Sleeping process will be reawakened and will start to run again.</li>
</ul>
</li>
<li>_S_KILL_TREE<ul>
<li>If the Variable WT_USE_PARENT_TREE is true, this will kill the signaled object and any child objects it created. This will act recursively until all children, grandchildren, great grandchildren etc. have been killed.</li>
</ul>
</li>
<li>_S_SLEEP_TREE<ul>
<li>If the Variable WT_USE_PARENT_TREE is true, this will Sleep the signaled object and any child objects it created. This will act recursively until all children, grandchildren, great grandchildren etc. have been Slept.</li>
</ul>
</li>
<li>_S_WAKE_TREE<ul>
<li>If the Variable WT_USE_PARENT_TREE is true, this will Wake the signaled object and any child objects it created. This will act recursively until all children, grandchildren, great grandchildren etc. have been Wakened.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="CollisionsPage"></a>
Detecting Collisions</h2>
<p>Collision Objects will only collide with other collision objects, NOT Render Objects. When a Collision Object is created it must be passed a pointer to a Render Object which will define it's translation. This should be the first argument passed to a Collision Object.</p>
<p>Collision Objects are created using the _CREATE() Macro and killed using the _KILL() Macro, as per a process. They can be slept and woken, like other objects. When Created a Collision Object needs to be linked to a process and a Renderable object. In the initialiser a pointer to a Render Object and a <a class="el" href="classc_process.html" title="This is the base code for a process. This will automatically create a new process. It will hand itself to cKernel to be processed every frame. Any Processes created by the user should inherit this type to be handled by cKernel automatically. Initialisation code should go in the constructor of the user type. Linking to cKernel is performed automatically by cProcess. Update code should go in the function Run(). Coed performed when a process is killed should go in the function Stop(). NOT the destructor. Code to handle Sleeping and Waking signals should go in OnSleep() and OnWake(). Code to handle interaction of two processes should go in either processes UserSignal() function.">cProcess</a> should be handed to the object. Collisions can be Filtered based on an unsigned integer value. When a Collision check is made, a filter can be specified (if not specified or specified as 0 then all collision objects will be checked for a collision) allowing the user only to check against objects the user is interested in. Collisions are very slow and the number of checks should always be minimised. Sphere Collisions are the fastest type, but do not allow any adjustment to fit the object. Objects should be given a filter value to allow them to be searched based on user defined properties. If the objects have no filter they will only be searched when a filter free search is performed. Collision Objects need a media type to define how and when they collide. Objects which are linked to a Renderable Object will be killed when their Renderable object is killed. As such Killing them is not required. This is defined using the Type Function which gives the Collision Object the data it needs and sets the type of collision Object it will be. There are many ways that Type can be set - either handing a pointer to Collision Data object: <br/>
 <br/>
 Types of Collision Data: cCollisionSphere<br/>
 cMeshCollision<br/>
 cCollisionRay<br/>
 cCollisionBeam<br/>
 cCollisionBox<br/>
 cCollisionBoxFile<br/>
 <br/>
 or Handing it the data it needs to generate one:<br/>
 Float : Sphere Collision.<br/>
 Two Floats : Beam - (Length, Radius) <br/>
 Six Floats : Box Collision - (+X, -X, +Y, -Y, +Z, -Z) <br/>
 Float Pointer to Six Floats : Box Collision - (+X, -X, +Y, -Y, +Z, -Z) <br/>
 <a class="el" href="classc_render_object.html" title="This class contains the base code for all renderable objects. Any renderable object should inherit th...">cRenderObject</a> Pointer : Ray Object (will generate a beam encapsulating the space the object has moved through this frame - suitable for fast moving objects which will be modelled as spheres). <br/>
</p>
<div class="fragment"><pre class="fragment"> MyProcess::MyProcess()
 {
  mpRender=_CREATE(TexturedModel());
  mpCollision=_CREATE(<a class="code" href="classc_collision_object.html" title="This Object is the base object for detecting collisions. This object should be created and passed a p...">cCollisionObject</a>(mpRender,<span class="keyword">this</span>));

  mpCollision-&gt;SetType(10.0f);
  mpCollision-&gt;CollisionFilter(1);
 }

 <span class="keywordtype">void</span> MyProcess::Run()
 {
 uint32 CollisionFilterValue;
 CollisionFilterValue=2;
  vProcess *lpProc;
  <a class="code" href="classc_collision_list.html" title="This is generated by doing Collision Detection with an object. This will cache all the detected colli...">cCollisionList</a>* lpList;
  lpList = mpCollision -&gt; GenerateCollisionList( CollisionFilterValue );
        _COLLISION_PROCESS_LIST(lpList,lpProc)
        {
                                _KILL(lpProc);
        }
        <span class="keyword">delete</span> lpList;

 }
</pre></div> <h2><a class="anchor" id="RenderNodesPage"></a>
Creating Local Co-ordinate systems</h2>
<p>WTcRenderNode.h WTcNodeList.h</p>
<p><b> <a class="el" href="classc_render_node.html" title="This is a dynamic render tree branch. This class stores a dynamic list of cRenderObjects called mpObj...">cRenderNode</a>: </b> RenderNodes are a special type of Render Object. Render Nodes have no visual rendering to screen. Instead they manipulate other Render Objects. Specifically, a Translation applied to a Render Node will affect any Render Objects Controlled by the RenderNode. This means the objects controlled by the Render Node will move as if the Render Nodes position was 0,0,0.</p>
<div class="fragment"><pre class="fragment"> mpNodePoint=_CREATE(<a class="code" href="classc_render_node.html" title="This is a dynamic render tree branch. This class stores a dynamic list of cRenderObjects called mpObj...">cRenderNode</a>());
 mpNodePoint-&gt;Position(0.0f,0.0f,0.0f);
 mpModel=_CREATE(<a class="code" href="classc_model.html" title="A standard Textured Model renderable object.">cModel</a>(mpNodePoint));
 mpModel-&gt;Position(10.0f,0.0f,0.0f);

 <span class="comment">// mpModel is now at 10.0f,0.0f,0.0f.</span>

 mpNodePoint-&gt;Position(10.0f,0.0f,10.0f);

 <span class="comment">// mpModel is now at 20.0f,0.0f,10.0f.</span>

 mpNodePoint-&gt;RotateY(3.1416); <span class="comment">//(rotate 90 degrees)</span>

 <span class="comment">//Model is now at 0.0f,0.0f,-10.0f.</span>
</pre></div><p>To control a Render Object by a Render Node object pass a pointer to the Render Node as the first argument in the Render Objects Constructor. Render Node objects can control any Render Object, including Render Nodes. This means that there can be many levels of Render Nodes before reaching a Renderable Object, making positioning of complex positional relationships easy. <br/>
 <br/>
 <b> cNodeList:</b> There are also NodeLists. These are static objects. They are initialised to hold a certain number of objects and only support rotations around the local axis. These are good for predictable structure shapes which do not change often. Each object is given a level and will position and rotate itself around the last object with a lower depth value.</p>
<div class="fragment"><pre class="fragment"> <span class="comment">//Create a Tree with 14 slots.</span>
 mpNodeList=_CREATE(cNodeList(14));

 <span class="comment">//Create 14 new cModels to fill the NodeList</span>
 uint32 liCount;
 <span class="keywordflow">for</span>(liCount=0;liCount&lt;14;++liCount)
 {
        _CREATE(mpNodeList);
 }

 <span class="comment">//Set Mesh and Level for each Item</span>
 <span class="comment">//Make Object 0 use the Mesh &quot;Torso&quot;</span>
 mpNodeList-&gt;GetListItem(0)-&gt;Mesh(<span class="stringliteral">&quot;Torso&quot;</span>));
 <span class="comment">//The torso is the top of the tree. This is the object all other objects will base their position on.</span>
 mpNodeList-&gt;SetLevel(0,0);

 <span class="comment">//Make Object 1 use the Mesh &quot;Head&quot;</span>
 mpNodeList-&gt;GetListItem(1)-&gt;Mesh(<span class="stringliteral">&quot;Head&quot;</span>));
 <span class="comment">//Make Object 1 linked to the Torso (last object with a Depth lower than this objects)</span>
 mpNodeList-&gt;SetLevel(1,1);

 <span class="comment">//Make Object 2 use the Mesh &quot;LeftUpperArm&quot;</span>
 mpNodeList-&gt;GetListItem(2)-&gt;Mesh(<span class="stringliteral">&quot;LeftUpperArm&quot;</span>));
 <span class="comment">//Make Object 2 linked to the Torso.</span>
 mpNodeList-&gt;SetLevel(2,1);

 <span class="comment">//Make Object 3 use the Mesh &quot;LeftForeArm&quot;</span>
 mpNodeList-&gt;GetListItem(3)-&gt;Mesh(<span class="stringliteral">&quot;LeftForeArm&quot;</span>));
 <span class="comment">//Make Object 3 Linked to the LeftUpperArm</span>
 mpNodeList-&gt;SetLevel(3,2);

 <span class="comment">//Make Object 4 use the Mesh &quot;LeftHand&quot;</span>
 mpNodeList-&gt;GetListItem(4)-&gt;Mesh(<span class="stringliteral">&quot;LeftHand&quot;</span>));
 <span class="comment">//Make Object 4 Linked to the &quot;LeftForeArm&quot;</span>
 mpNodeList-&gt;SetLevel(4,3);

 <span class="comment">//You have now built a torso with a head and a left arm. repeat for the other limbs.</span>
 mpNodeList-&gt;GetListItem(5)-&gt;Mesh(<span class="stringliteral">&quot;RightUpperArm&quot;</span>);
 mpNodeList-&gt;SetLevel(5,1);

 mpNodeList-&gt;GetListItem(6)-&gt;Mesh(<span class="stringliteral">&quot;RightForeArm&quot;</span>);
 mpNodeList-&gt;SetLevel(6,2);

 mpNodeList-&gt;GetListItem(7)-&gt;Mesh(<span class="stringliteral">&quot;RightHand&quot;</span>);
 mpNodeList-&gt;SetLevel(7,3);

 mpNodeList-&gt;GetListItem(8)-&gt;Mesh(<span class="stringliteral">&quot;LeftThigh&quot;</span>);
 mpNodeList-&gt;SetLevel(8,1);

 mpNodeList-&gt;GetListItem(9)-&gt;Mesh(<span class="stringliteral">&quot;LeftShin&quot;</span>);
 mpNodeList-&gt;SetLevel(9,2);

 mpNodeList-&gt;GetListItem(10)-&gt;Mesh(<span class="stringliteral">&quot;LeftFoot&quot;</span>);
 mpNodeList-&gt;SetLevel(10,3);

 mpNodeList-&gt;GetListItem(11)-&gt;Mesh(<span class="stringliteral">&quot;RightThigh&quot;</span>);
 mpNodeList-&gt;SetLevel(11,1);

 mpNodeList-&gt;GetListItem(12)-&gt;Mesh(<span class="stringliteral">&quot;RightShin&quot;</span>);
 mpNodeList-&gt;SetLevel(12,2);

 mpNodeList-&gt;GetListItem(13)-&gt;Mesh(<span class="stringliteral">&quot;RightFoot&quot;</span>);
 mpNodeList-&gt;SetLevel(13,3);

 <span class="comment">//You now have a skeleton for a humanoid robot. Moving limbs requires moving any one object and the rest of the objects linked will autoamtically move.</span>
 <span class="comment">//This can be build into a MeshTree in the IMF Handler so it can be loaded from a file.</span>
</pre></div> <h2><a class="anchor" id="MultipleCamerasViewports"></a>
Multiple Cameras and Viewports</h2>
<p>Bamboo has full support for multiple <a class="el" href="classc_camera.html" title="This class will control the rendering of the render tree. It will handle all the render objects and h...">cCamera</a> Objects, cViewport objects and rendering to specified regions. cCameras are seperate cameras. They store a scene graph (tree of vRenderObjects and vRenderNodes) and will render them to the specified region of the screen. cCameras are controlled by signals, so _CREATE() should be used to create them and _KILL() should be used to kill them. Once killed, all objects in their scene graph will be destroyed and so should not be accessed. Each <a class="el" href="classc_camera.html" title="This class will control the rendering of the render tree. It will handle all the render objects and h...">cCamera</a> Object has it's own objects so creating a Render Object in one will not affect another. <br/>
 cViewports are slightly different. They also render a scene graph to the screen in a specified region, but do not have a scene graph of their own. All cViewports are owned by a <a class="el" href="classc_camera.html" title="This class will control the rendering of the render tree. It will handle all the render objects and h...">cCamera</a> object and will render the <a class="el" href="classc_camera.html" title="This class will control the rendering of the render tree. It will handle all the render objects and h...">cCamera</a> objects scene graph. This is much more efficient than using a second <a class="el" href="classc_camera.html" title="This class will control the rendering of the render tree. It will handle all the render objects and h...">cCamera</a> as only one scene graph is stored and updated. It allows the user to view the same scene as it's camera from a different position, rotation or perspective. All vRenderObjects can be passed a <a class="el" href="classc_camera.html" title="This class will control the rendering of the render tree. It will handle all the render objects and h...">cCamera</a> as an argument in their constructor which will make them use the specified <a class="el" href="classc_camera.html" title="This class will control the rendering of the render tree. It will handle all the render objects and h...">cCamera</a>. If they are passed a vRenderNode as a parameter, they will become a child of the <a class="el" href="classc_camera.html" title="This class will control the rendering of the render tree. It will handle all the render objects and h...">cCamera</a> which owns the vRenderNode which owns the vRenderObject. the _CAMERA pointer will always point to the first <a class="el" href="classc_camera.html" title="This class will control the rendering of the render tree. It will handle all the render objects and h...">cCamera</a> object and will be used as a default when no <a class="el" href="classc_camera.html" title="This class will control the rendering of the render tree. It will handle all the render objects and h...">cCamera</a> is specified. </p>
<div class="fragment"><pre class="fragment"> <span class="comment">//Create a Model on the default cCamera object and have the cCamera follow it at a distance of 60.</span>
 <a class="code" href="classc_model.html" title="A standard Textured Model renderable object.">cModel</a>* lpModel=_CREATE(<a class="code" href="classc_model.html" title="A standard Textured Model renderable object.">cModel</a>);
 lpModel-&gt;<a class="code" href="classc_model.html#aaf5401048d8b857d276ca4821a975009" title="Will set the mesh the model will use.">Mesh</a>(<span class="stringliteral">&quot;MyMesh&quot;</span>);
 lpModel-&gt;<a class="code" href="classc_render_object.html#abd47a58de22adfe1e9a1970f66a2f4cd" title="Will set the shader this object will use.">Shader</a>(<span class="stringliteral">&quot;TexturingProgram&quot;</span>);
 lpModel-&gt;Texture(<span class="stringliteral">&quot;MyTexture&quot;</span>);
 _CAMERA-&gt;Follow(lpModel,60.0f);

 <span class="comment">//Create a Viewport owned by the default cCamera object. and have the cCamera follow it at a distance of 60.</span>
 cViewport *lpViewport=_CREATE(cViewport);
 <span class="comment">//Set the View port to render to the area X : 100 - 300 and Y : 100 - 400.</span>
 lpViewport-&gt;Viewport(100.0,100.0,200.0,300.0);
 <span class="comment">//Set the Viewport to follow the model at a distance of 20</span>
 lpViewport-&gt;Follow(lpModel,20.0);

 <span class="comment">//The model will appear twice on screen.</span>
 <span class="comment">//Once across the entire screen at a distance of 60.</span>
 <span class="comment">//Once in the area, X:100-300 Y:100-400 at a distance of 20.</span>


 <span class="comment">//Create a new cCamera. Set it to use the region proportional to the screen size of X:0.5-0.75 Y:0.5-0.6.</span>
 <a class="code" href="classc_camera.html" title="This class will control the rendering of the render tree. It will handle all the render objects and h...">cCamera</a> *lpCamera=_CREATE(<a class="code" href="classc_camera.html" title="This class will control the rendering of the render tree. It will handle all the render objects and h...">cCamera</a>);
 lpCamera-&gt;<a class="code" href="classc_viewport_control.html#a56d7ce89ad28c3c47efa12e2460bbe5c" title="This will turn on or off the use of Proportional co-ordinate systems.">Proportional</a>(<span class="keyword">true</span>);
 lpCamera-&gt;<a class="code" href="classc_viewport_control.html#aa6a247ab5ceba96ba5fb7e62f437bcab" title="This will set the fixed size of a cViewport Control. Takes X,Y, Width and Height.">Viewport</a>(0.5,0.25,0.5,0.1);

 <span class="comment">//Create a Model and make the cCamera lpCamera its parent.</span>
 <a class="code" href="classc_model.html" title="A standard Textured Model renderable object.">cModel</a>* lpModel2=_CREATE(<a class="code" href="classc_model.html" title="A standard Textured Model renderable object.">cModel</a>(lpCamera));
 lpModel2-&gt;<a class="code" href="classc_model.html#aaf5401048d8b857d276ca4821a975009" title="Will set the mesh the model will use.">Mesh</a>(<span class="stringliteral">&quot;MySecondMesh&quot;</span>);
 lpModel2-&gt;<a class="code" href="classc_render_object.html#abd47a58de22adfe1e9a1970f66a2f4cd" title="Will set the shader this object will use.">Shader</a>(<span class="stringliteral">&quot;TexturingProgram&quot;</span>);
 lpModel2-&gt;Texture(<span class="stringliteral">&quot;MySecondTexture&quot;</span>);

 <span class="comment">//Make the second Camera Follow lpModel2.</span>
 lpCamera-&gt;<a class="code" href="classc_camera_matrix4.html#aeee787e0f5895a613e8be9efbade408f" title="This will make the camera position itself the distance lfDist behind the matrix lpOther facing in the...">Follow</a>(lpModel2,30);

 <span class="comment">//lpModel will not appear in the screen region used by lpCamera as the object is not owned by lpCamera.</span>
 <span class="comment">//lpModel2 will not appear in either the screen region used by the default camera or its viewport.</span>
 <span class="comment">//As the object is not owned by the default camera.</span>
</pre></div> <h2><a class="anchor" id="IMFGenerationPage"></a>
IMF File Generation and Usage</h2>
<p>IMF Files are generated by the IMF Compiler. The IMF Compiler is a seperate program to the Bamboo engine and has a text based interface. The Compiler should be run from the terminal, so the user can view and use the interface.</p>
<p>Everytime the user runs the program will start with an empty IMF File. IMF Files contain media blocks. Each block begins with a type identifier to identify the type of media stored in the block. This is followed by a size specifier defining the amount of data in the remainder of the block. Finally the Block has a character string storing the reference.<br/>
 The main task the user will perform is to add Media to the IMF File. Each Media file added will require a reference (a character string which allows the media to be identified in the Bamboo Engine) and often other data to fully define the object.<br/>
 Media can often be converted into several different types of IMF Blocks. e.g. A image can be converted to a 2D Texture, a Landscape height map or if it is 64 times taller than it is wide into a font. Each of these require different information to generate the object.<br/>
 An IMF File can contain many blocks all with different media types in. This allows the user to group media into sensible sets which are interdependant, eg a tank body model, a tank turret model, a tank shell model, a texture for the tank, and a model list representing the skeletal structure for the tank. This ensures that all inter dependant media can be loaded with a single call.<br/>
 Each level of the menu defines the options available to the user, selecting 0 will always move the user back up to the previous level. Otherwise, the user should select the desired option, insert the number representing it and press enter.<br/>
</p>
<p>To add each item, select 1 from the main menu. Each file Name (including file type) which is entered will be added to the IMF File as a new block. The system will request all the information required to generate the object, then add it to the IMF File as a new block. Take care when selecting the references as they are the only way to access the media in the Bamboo Engine.<br/>
 Once all the required media files are added to the IMF file, it can be written to the harddrive, by selecting option 7. The IMF file type should be included by the user.<br/>
 IMF Files can be loaded and will add all their blocks to the end of all the blocks in the current IMF File. This allows the user to add new media to previous groupings.<br/>
</p>
<p>Media Types Supported:<br/>
 Shader Code:<br/>
 .shd (text files containing GLSL (GL Shader Language) shader code)<br/>
 Model Files:<br/>
 .x<br/>
 .obj<br/>
 .q3d<br/>
 Model Files can be converted into:<br/>
 Meshes (3D Models, including Normals and UV if available)<br/>
 Collision Objects (Currently only supporting convex faces)<br/>
 Box Collision Objects <br/>
 Images:<br/>
 .bmp<br/>
 Image Files can be converted into:<br/>
 2D Textures<br/>
 Fonts (are composed of 64 vertical characters, with equal width and height)<br/>
 Landscape Height Maps (Produces a map with a polygon per pixel in the image, with RGB(0,0,0) being no height and RGB(1,1,1) being maximum terrain height)<br/>
 Sound Files: <br/>
 .wav<br/>
 Sound Files can be converted into:<br/>
 Audio Data files<br/>
 <br/>
 </p>
<h3><a class="anchor" id="IMFUse"></a>
Using the IMF Handler :</h3>
<p>The IMF Handler has a graphical interface to ease control of it. The large list box on the left of the GUI lists all the references of objects in the file. Clicking on an item in the list will display the objects information in the middle section of the GUI. On the right are the settings and controls for the IMF Handler. </p>
<h3><a class="anchor" id="IMFControls"></a>
Using the IMF Handler Controls :</h3>
<p>The "Add Media File" button :<br/>
 Clicking the "Add Media File" button will open a file dialog. Selecting a file will load it into the current IMF. The IMF Handler will then ask for a string reference to identify the media file in the game engine. The files can be filtered based on types. Only types supported by the IMF Handler will be displayed. When the file is loaded it will use the current settings on the GUI. This means settings should be set before trying to add a new media file. These settings determine what type of internal format the file will be loaded into. The specifics of loading each file type will be listed in the section for the appropriate file types. <br/>
 The "Add Shader Program" button :<br/>
 Shader Programs are not loaded from a file, but generated in the IMF Handler itself. The "Add Shader Program" button will ask for a string reference to identify the shader program. It will then create a new Shader Program in the current Media file. This can be modified by following the instructions in the Shader Program section. <br/>
 The "Add Render Tree" button :<br/>
 This allows the user to generate cNodeList Objects and store them in an IMF file. <br/>
 The "Save IMF As..." button :<br/>
 Clicking the "Save IMF As..." button will save the current IMF. It will create a dialog to ask for the file name to use. This will write all the objects and references currently loaded into an IMF file. You do not need to add '.imf' to the end of the file name. The files can then be loaded by Bamboo. <br/>
 The "Remove Media" button :<br/>
 The "Remove media" button will remove a single selected media item from the list. Select the item from the Reference List and then click the "Remove Media" button. The "Clear File" button :<br/>
 The "Clear File" button will remove all the items from the IMF File. Essentially this will clear the current IMF file and create a new empty file. <br/>
 The "Quit" button :<br/>
 The "Quit" button will quit the program. It will not save the IMF. All changes to the file will be lost. </p>
<h3><a class="anchor" id="IMFSettings"></a>
IMF Handler Settings :</h3>
<p>The Handler Settings section can be found in the top right of the GUI. <br/>
 "Load Model Files As..." : <br/>
 This section has two check boxes. If the "Renderable Object" check box is ticked any model file will be converted into a Renderable mesh. If the "Collision Objects" check box is ticked any model file will be converted into a collision mesh. In both cases, the IMF Handler will require a reference for the generated mesh. If both boxes are ticked both will be generated. The Renderable Mesh will be generated first and will require its reference first. <br/>
 "Load Image Files As..." : <br/>
 This section has two radio boxes. Only one can ticked at any time. While the "Textures" radio button is ticked, Image files will be converted into textures. Textures are images that can be glued onto 3D models to texture their surface. While the "Height Maps" radio button is ticked, Image files will be converted into a Landscape height map. The lightness of each pixel represents the height of the landscapes vertex. RGB = 0,0,0 is the lowest point on the height map, RGB = 255,255,255 being the highest point on the height map. "Load Shaders As..." : <br/>
 The "Load Shaders As..." section has three radio buttons. Only one can be selected at any time. While the "Vertex Shaders" radio button is ticked any shader files will be loaded, and processed as Vertex shaders. This means they will operate on each vertex. They can receive Uniform or Attribute variables. They can produce varying values for passing to fragment shaders. While the "Fragment Shaders" radio button is ticked and shader files will be loaded, and processes as Fragment shaders. This means they will operate on each fragment. They can receive Uniform and varying variables. Attributes cannot be accessed by fragment shaders. Varying variables which have been produced by a vertex shader can be accessed by a Fragment shader. The varying values are interpolated from the varying values created by the verteces. Currently the "Geometric Shaders" radio button cannot be ticked. "Set Font Resolution..." : <br/>
 The "Set Font Resolution..." value is the width and height of font characters that will be generated. When true type font files are loaded into Bamboo, they are rendered into character textures as OpenGL is optimised for rendering textures rather than true type fonts. For optimal performance these characters are restricted to multiples of 8. The larger the character size the clearer the characters will be, however the larger the files generated will be. </p>
<h3><a class="anchor" id="IMFTypes"></a>
Specifics of media types :</h3>
<p>General Media Information : <br/>
 All media will require a reference to allow it to be identified in Bamboo. This is a string. The IMF Handler will automatically assign it a new reference string, but this should be set as a descriptive string by the user. This can be changed for all media types by selecting the media files reference from the Reference List on the left of the GUI and typing a new reference ino the box labelled "Reference:" in the middle section of the GUI. This will change the medias reference. <br/>
 Selecting a file from the Reference List on the left will also configure the middle section of the GUI to display settings controls and data relating to the file selected.<br/>
 Model Meshes : <br/>
 When a Models reference is selected in the references list. It will configure the middle section of the GUI to display the models. It will show the list of Verteces, Normals, UV Co-ordinates and Vertex Indices requried to generate the triangulated faces. All faces are triangulated when compiled to optimise performance in OpenGL. <br/>
 Collision Meshes : <br/>
 A Collision Mesh cannot have any concave faces. Any concave faces (or holes in the surface) will lead to unexpected collision events. Concave faces will mean some collisions which should collide are missed. Conversely holes will catch collisions which do not exist. It also needs to have a minimal number of faces to define the boundaries of the object it is representing. Accuracy of collision meshes is less important than speed of calculations. The system will optimise out any polygon that will statistically have a minimal chance of affecting whether a collision is detected or not. Traditionally Collision Meshes have 10 - 30 polygons, but obviously the number required depends on the complexity of the model being represented. <br/>
 When a collision mesh is selected from the Reference List it will display the collision meshes critical data. A collision Mesh is actually compiled into two seperate data sets. A set of verteces and a set of polygons. A vertex has three positions representing the X,Y and Z co-ordiantes of the vertex. A Plane is composed of four values. Three values for multiplying with vertex co-ordinates to generate a distance from the origin perpendicular to the plane. The fourth value is the planes distance from the origin. This makes it quick to calculate if any point in the same co-ordinate system is above or beneath the plane. Texture Images : <br/>
 Textures should have a width and height which is a power of 2 (2,4,8,16,32,64...). This will make UV mapping more accurate and avoid the texture being padded by the graphics card. The larger the texture the larger the file generated, but the resulting image will be clearer at large magnifications. OpenGL will automatically generate mip maps for rendering the image at lower magnifications, so only the largest texture resolution desired need be compiled. When selected from the reference list the IMF Handler will display the width, height and color depth of the texture loaded. Height Maps : <br/>
 Landscapes are created from a square matrix of polygons. Each pixel in the image used to generate a height map will create a vertex. This means the landscape generated will have a number of verteces across equal to the width of the image in pixels. The landscape will have a number of verteces along equal to the height of the image in pixels. This means the number of polygons across and along are one less than the images width and height. The height of each vertex is determined by the lightness of its pixel. RGB = 0,0,0 is the lowest point on the height map, RGB = 255,255,255 being the highest point on the height map. When a Height Map is selected from the reference list the IMF Handler will display the dimensions of the height map generated. It will also update the GUI with some settings specific to the landscape selected. Changing the values will only update the selected landscape.</p>
<ul>
<li>The value labelled "Tile X Size" is the distance in the X dimension between each vertex in the landscape.</li>
<li>The value labelled "Tile Z Size" is the distance in the Z dimension between each vertex in the landscape.</li>
<li>The value labelled "Height Range" is the value that the Y dimension of a vertex will be for a pixel with RGB = 255,255,255. This sets the highest point that is possible in the landscape.</li>
<li>The "Gradient Factor" is a 'skewing' effect. With verteces which are the same distance apart the gradient of any plane is determined solely by the height difference between the verteces used to generate them. This means that a vertical plane is impossible. The gradient factor determines how much verteces can move towards each other based on the height difference in the verteces. A gradient factor of one can produce a vertical plane from sufficiently spread verteces. Essentially this makes the landscape less rolling based on the range of 0 to 1. Every time the gradient effect is applied it is irreversable and stacks with any other gradient factor applied. To apply the gradient effect, click the "Apply Gradient" button.</li>
<li>The "Apply Gradient" button will apply the currently selected gradient factor to the landscape.</li>
</ul>
<p>Shader Files : <br/>
 Shader Files are text files. Shaders are simply programs which are performed by the graphics card. Many shaders are available on the internet. The GLSL (GL Shading Language) is similar to C but with extra variable types, defined variables and values specific to rendering images. There are three types of Shader program. Vertex, Fragment and Geometric. Currently Geometic is not supported. Shaders are combined into Shader Programs. A shader program must have at least one vertex shader and one fragment shader. Geometry shaders are optional. Vertex Shaders control the vertices that make up a mesh. They can change the position of the verteces, values of different properties at the vertices (which are linearly interpolated across a polygons face). <br/>
 Bamboo Offers a selction of useful 'positioning matrices' mmGlobal , mmCamera , mmProjection , mmCombined. <br/>
 It will pass the objects Global Position Matrix in to a mat4 called mmGlobal. </p>
<div class="fragment"><pre class="fragment"> uniform mat4 mmGlobal;
</pre></div><p> mmCamera is just the Camera Matrix. This is the Cameras Position and Rotation </p>
<div class="fragment"><pre class="fragment"> uniform mat4 mmCamera;
</pre></div><p> mmProjection is just the Projection Matrix. This is the function to map 3D co-oridinates to the screen. Essentially it controls Perspective. </p>
<div class="fragment"><pre class="fragment"> uniform mat4 mmProjection;
</pre></div><p> mmCombined is the Camera and Projection Matrices multiplied together. </p>
<div class="fragment"><pre class="fragment"> uniform mat4 mmCombined;
</pre></div><p> These should be used to find the position of each vertex, there are several common ways to use the matrices (They should be used to find an objects position). The order of Matrix multiplications do matter. Using mmCombined is much more efficient but some shaders will want to use the camera and Projection matrices seperately. </p>
<div class="fragment"><pre class="fragment"> gl_Position=mmCombined*mmGlobal*gl_Vertex;
 gl_Position=mmProjection*mmCamera*mmGlobal*gl_Vertex;
</pre></div><p> For 2D Objects only the mmProjection and mmGlobal are passed. The mmCamera Matrix will always be an identity matrix for 2D objects. Fragment Shaders control the render color of individual pixels. The Vertex shader is run once for every vertex in the model. The Fragment shader is run once for every pixel on the screen where the model is visible. A Geometry Shader (GS) is a Shader program that governs the processing of primitives. It happens after primitive assembly, as an additional optional step in that part of the pipeline. A GS can create new primitives, unlike vertex shaders, which are limited to a 1:1 input to output ratio. A GS can also do layered rendering; this means that the GS can specifically say that a primitive is to be rendered to a particular layer of the framebuffer. GS will be enabled in a later version of Bamboo. <br/>
 <b> One requirement is that attribute and uniform variables are declared individually on their own line. This is a requirement of the IMF Handler rather than GLSL. </b> <br/>
 When a shader is selected from the Reference List it will modify the GUI to display the Shader File display. This gives the option to change the type of shader that the currently selected shader will be used as. Clicking the appropriate radio button in the middle section of the GUI will change the type of the shader. Geometry shaders cannot be selected. It will also display the detected variables and whether they are uniform or attribute. Finally it will also display the shaders code. <br/>
 Shader Programs : <br/>
 A Shader program is a collection of Shader files, which forms a Shader Program. It must have at least one Vertex Shader and one Fragment shader. You cannot include any shader in a Shader Program more than once. If you run out of spaces in a Shader Program you must increase the Shader Programs size as described later before you can add more shader files. All vertex shaders should be included first. Followed by all the Fragment Shaders. The "Add Shader Program" button will create a Shader Program. It will then ask for a reference for the Shader Program. It is important that Shader Files are loaded before loading a Shader Program which contains them. If in the same IMF it is important put the Shader Files before any Shader Program which uses them. Selecting the Shader Program from the Reference List will modify the GUI to display the Shader File display. <br/>
 The value labelled "Number of Shaders" is the number of Shader files that the Shader Program will use. This can be changed by the user. <br/>
 The box labelled "New Shader:" is used to add new Shader Files to the Shader Program. Type in the Reference of the Shader File in the box, press enter and it will be added to the current Shader Program. <br/>
 The button labelled "Select Shader From File" will bring up a idalog listing all the references for Sahder Files in the current IMF File. Select the desired reference from the drop down menu and click 'OK' to add it to the currently selected Shader Program. This will only list vertex objects in the current file. <br/>
 The "Remove Shader Reference" button will remove the Shader Reference in the Shader Program from the Shader Program. Sound Files : <br/>
 Sound files are all compiled from .wav files. When a sound file is selected from the reference list on the left it will produce a list of information about the file.</p>
<ul>
<li>Format:</li>
<li>BlockSize:</li>
<li>Sample Rate:</li>
<li>Byte Rate:</li>
<li>Block Align:</li>
<li>Data Volume:</li>
<li>Compression:</li>
<li>Channels:</li>
<li>Bits Per Sample:</li>
<li>Contains Extra Data</li>
</ul>
<p>Font Files : <br/>
 Font files are formed from ttf files. For speed the IMF Handler renders individual images for each character at the font size specified in the GUI controls section. Some fonts extend beyond the area that Bamboo uses. This can cause the IMF Handler to crash. The IMF Handler should detect this is the case and raise a warning asking if you wish to continue. Often the IMF Handler will be able to handle fonts which extend outside the acceptable range but not always. If a warning is raised it may crash the IMF Handler, so continue at your own risk. <br/>
 Selecting a font file from the Reference List on the left of the GUI will modify the central section of the GUI to display the fonts character dimensions and color depth. Font files are compiled as 32 bit as they require an alpha channel and this allows effects to be applied to them in future versions. <br/>
 Mesh Trees : <br/>
 Mesh Trees are generated in the IMF Handler. They allow you to produce structures composed of seperate objects. These objects can be ordered into a tree with a hierachy of linking. This means an object can be linked to another object making its movements based off the movements of the object with a lower depth. Objects in a Mesh Tree must be <a class="el" href="classc_model.html" title="A standard Textured Model renderable object.">cModel</a> types and so can be given a Mesh, Texture and shader. The Mesh and Shader are compulsory for an object to be rendered. The Texture is optional. The objects are also given a depth. Each object will be linked to the previous object in the list with a lower depth value. 0 should be the base object. Objects which base their movement off of the base object should have a depth value of 1. Objects based off of an object with a depth of 1 should have a depth of 2 and be after the object they wish to follow and before the next object with a depth value of 1. <br/>
 <br/>
 <br/>
 A0 <br/>
 |- B1 <br/>
 | |- E2 <br/>
 | | |- K3 <br/>
 | |<br/>
 | |- F2 <br/>
 |<br/>
 |- C1 | | <br/>
 | |- G2 <br/>
 | |- H2 <br/>
 |<br/>
 |- D1 <br/>
 | |- I2 <br/>
 |- J2 <br/>
 <br/>
 would be listed (Showing order and depth value of each item): <br/>
 A0 <br/>
 B1 <br/>
 E2 <br/>
 K3 <br/>
 F2 <br/>
 C1 <br/>
 G2 <br/>
 H2 <br/>
 D1 <br/>
 I2 <br/>
 J2 <br/>
 </p>
</div></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Jun 6 2012 10:28:49 for Bamboo by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
