This section will give a series of examples of programs for games. Initially they will be very simple. Later examples will show expanded functionality.
\begin{DoxyEnumerate}
\item \hyperlink{_code_program_examples_BouncingBallExample}{Example of a bouncing ball}
\item \hyperlink{_code_program_examples_ThreeDimensionBouncingBallExample}{Example of a ball bouncing in 3 Dimensions}
\item \hyperlink{_code_program_examples_SoundBouncingBallExample}{Example of a bouncing ball with a bounce sound}
\item \hyperlink{_code_program_examples_BulletsBouncingBallExample}{Making the camera controllable. Adding bullets}
\item \hyperlink{_code_program_examples_CollisionsBouncingBallExample}{Example with Bullet and Ball collisions}
\item \hyperlink{_code_program_examples_ReSpwaningBouncingBallExample}{Example of Signals. Giving a continual supply of targets.}
\item \hyperlink{_code_program_examples_CompleteNoCommentsBouncingBallExample}{Previous Example without comments}
\end{DoxyEnumerate}\hypertarget{_code_program_examples_BouncingBallExample}{}\section{Example of a bouncing ball.}\label{_code_program_examples_BouncingBallExample}
So lets start with a bouncing ball. This ball will bounce up and down on a plane going through Y = 0. When using Bamboo Programs the ESC key is automatically tagged to exit the program.


\begin{DoxyCode}
 //Declare a new type of Process cCore.
 //class cCore : public cProcess
 _PROCESS(cCore)
 {
 public:
 //Create pointer so cCore can  access the object it creates.
 cModel *BallPointer;

 float BallSpeed;

  //Constructor - Initialisation code.
        cCore()
        {
        //Load the imf pack with objects for demonstration 1.
        //This contains a renderable spherical mesh called BallModel.
        //This contains a texture called BallTexture.
        //This also contains a shader called TexturingProgram.
                 _LOAD_FILE( "Demonstration1.imf" );

        //Create a Textured Model to put the ball on screen.
                BallPointer =  _CREATE(cModel);

        //Set the mesh it will use.
                BallPointer -> Mesh( "BallModel" );

        //Set the Texture it will use.
                BallPointer -> Texture( "BallTexture" );

        //Set the Shader it will use.
                BallPointer -> Shader( "TexturingProgram" );

        //Set a start position.
        //This is relative to the camera.
        // The first value is left and right position of the object.
        // The second value is up and down position of the object.
        // The third value is forwards nd backwards.
                BallPointer -> Position( 0.0 , 20.0 , 30.0 );

        //The ball has been placed 30 units in front of the camera.
        //The ball has been placed 20 units up from the camera.

        //Set the ball so it is not moving at the start.
                BallSpeed = 0.0;
        };

        //This function will update the balls position every process cycle.
        void Run()
        {
                //Increase the balls speed downwards by a small amount.
                        BallSpeed = BallSpeed - 0.01;

                //Advance the Ball by its speed.
                //This uses the Global Y Axis as BallSpeed.
                //BallSpeed stores the balls speed.
                //A Local Advance would be affected by rotations.
                //A Global Advance will not.
                        BallPointer -> GAdvanceY( BallSpeed );

                //If the ball is closer to the 'ground' than its radius
                //then it has collided with the floor.
                //We will assume it has no radius to make this easier to follow.
                //This means the centre of the ball will touch the 'ground'
                if( BallPointer -> Y()  < 0.0 )
                {
                        //If the ball touched the ground
                        //it must be moving downwards
                        //so make the Ballspeed positive
                        //Making it bounce.
                        //abs() is a function which will return a positive value
                        //whether it was negative or not before.
                        //This will make the ball always bounce to the same heigh
      t.
                                BallSpeed = abs( BallSpeed );

                        //Changing the above line of code
                        //to the following line of code will reduce
                        //the height the ball bounces with each bounce.
                        //BallSpeed = abs( BallSpeed ) * 0.9 ;
                }
        };

        void Stop()
        {
                //When this dies we want the ball to disappear.
                        _KILL( BallPointer );

                //Stop BallPointer pointing at the model as it has been killed.
                        BallPointer = 0;
        };
};
\end{DoxyCode}
 \hypertarget{_code_program_examples_ThreeDimensionBouncingBallExample}{}\section{Example of a ball bouncing in 3 Dimensions.}\label{_code_program_examples_ThreeDimensionBouncingBallExample}
Now lets enclose it in a box of size +/-\/ 30 about 0,0,0 (The boundaries are
\begin{DoxyItemize}
\item X: -\/30 / 30
\item Y: -\/30 / 30
\item Z: -\/30 / 30 Lets also start it moving in a random direction.
\end{DoxyItemize}


\begin{DoxyCode}
 //Declare a new type of Process cCore.
 //class cCore : public cProcess
 _PROCESS(cCore)
 {
 public:
 //Create pointer so cCore can  access the object it creates.
 cModel *BallPointer;

 //Create a variable for each dimension the ball moves in.
 //This could be a c3DVf which is a 3 dimensional vector
 float BallSpeedX;
 float BallSpeedY;
 float BallSpeedZ;

  //Constructor - Initialisation code.
        cCore()
        {

        //Load the imf pack with objects for demonstration 1.
        //This contains a renderable spherical mesh called BallModel.
        //This contains a texture called BallTexture.
        //This also contains a shader called TexturingProgram.
         _LOAD_FILE( "Demonstration1.imf" );

        //Create a Textured Model to put the ball on screen.
        BallPointer =  _CREATE(cModel);

        //Set the mesh it will use.
        BallPointer -> Mesh( "BallModel" );

        //Set the Texture it will use.
        BallPointer -> Texture( "BallTexture" );

        //Set the Shader it will use.
        BallPointer -> Shader( "TexturingProgram" );

        //Set a start position.
        //This is relative to the camera.
        // The first value is left and right position of the object.
        // The second value is up and down position of the object.
        // The third value is forwards and backwards.
        BallPointer -> Position( 0.0 , 0.0 , 0.0 );

        //Move the camera back 60 units so it is outside the box.
        //It will look forwards and so look at the ball.
        _CAMERA -> Position (0.0 , 0.0 , -60);

        //Set the ball to move in a random direction at 0.1 units per frame
        //RANDOM_NUMBER is a random float between 0.0 and 1.0.
        BallSpeedX = RANDOM_NUMBER * 0.1;
        BallSpeedY = RANDOM_NUMBER * 0.1;
        BallSpeedZ = RANDOM_NUMBER * 0.1;

        };

        //This function will update the balls position every process cycle.
        void Run()
        {
                //Increase the balls speed downwards by a small amount.
                BallSpeedY = BallSpeedY - 0.01;

                        //Advance the Ball by its speed in all three Global axis.
      
                        //This is global as mentioned in the last example.
                BallPointer -> GAdvance( BallSpeedX , BallSpeedY , BallSpeedZ );

                //If the ball is outside any of the boundaries
                //reverse its direction in the appriopriate axis.
                //This is the same as previously, but with 6 boundaries instead o
      f 1.
                if( BallPointer -> X()  < - 30.0 )
                {
                        BallSpeedX = abs( BallSpeedX );
                }
                if( BallPointer -> X()  >  30.0 )
                {
                        BallSpeedX = -abs( BallSpeedX );
                }

                if( BallPointer -> Y()  < - 30.0 )
                {
                        BallSpeedY = abs( BallSpeedY );
                }
                if( BallPointer -> Y()  >  30.0 )
                {
                        BallSpeedY = -abs( BallSpeedY );
                }

                if( BallPointer -> Z()  < - 30.0 )
                {
                        BallSpeedZ = abs( BallSpeedZ );
                }
                if( BallPointer -> Z()  >  30.0 )
                {
                        BallSpeedZ = -abs( BallSpeedZ );
                }

        };

        void Stop()
        {
                //When this dies we want the ball to disappear.
                _KILL(BallPointer);
                //Stop BallPointer pointing at the model as it is killed.
                BallPointer = 0;
        };
};
\end{DoxyCode}
 \hypertarget{_code_program_examples_SoundBouncingBallExample}{}\section{Example of a bouncing ball with a bounce sound.}\label{_code_program_examples_SoundBouncingBallExample}
Lets take the program we used before and give it a bounce sound.


\begin{DoxyCode}
 //Declare a new type of Process cCore.
 _PROCESS(cCore)
 {
 public:
 //Create pointer so cCore can  access the object it creates.
 cModel *BallPointer;

 //Create a pointer so cCore can play the bounce sound.
 cAudioObject *BallBounce;

 //Create a variable for each dimension the ball moves in.
 //This could be a c3DVf which is a 3 dimensional vector
 c3DVf BallSpeed;

  //Constructor - Initialisation code.
        cCore()
        {
        //Load the imf pack with objects for demonstration 2.
        //This contains a renderable spherical mesh called BallModel.
        //This contains a texture called BallTexture.
        //This also contains a shader called TexturingProgram.
        //This also contains a bounce sound called BounceSound.
                 _LOAD_FILE( "Demonstration2.imf" );

        //Create a Textured Model to put the ball on screen.
                BallPointer =  _CREATE(cModel);

        //Set the mesh it will use.
                BallPointer -> Mesh( "BallModel" );

        //Set the Texture it will use.
                BallPointer -> Texture( "BallTexture" );

        //Set the Shader it will use.
                BallPointer -> Shader( "TexturingProgram" );

        //Set a start position.
        //This is relative to the camera.
        // The first value is left and right position of the object.
        // The second value is up and down position of the object.
        // The third value is forwards and backwards.
                BallPointer -> Position( 0.0 , 0.0 , 0.0 );

        //Set the ball to move in a random direction at 0.1 units per frame
        //RANDOM_NUMBER is a random float between 0.0 and 1.0.

        //Because this is an instance
    //(not a Bamboo engine object)
    //it should be accessed using the dot operator.
                BallSpeed.X( RANDOM_NUMBER * 0.1 );
                BallSpeed.Y( RANDOM_NUMBER * 0.1 );
                BallSpeed.Z( RANDOM_NUMBER * 0.1 );

        //Create an audio file for playing the bounce sound.
                BallBounce = _CREATE(cAudioObject);

        //Create Buffer the sound we want to play into the cAudioObject.
                BallBounce -> Buffer ( "BallSound" );

        };

        //This is the function that will update the balls position every process 
      cycle.
        void Run()
        {
                //Increase the balls speed downwards by a small amount.
                        BallSpeedY = BallSpeedY - 0.01;

                //Advance the Ball by its speed in all three Global axis.
                        BallPointer -> GAdvance( BallSpeed.X() , BallSpeed.Y() , 
      BallSpeed.Z() );

                //If the ball is outside any of the boundaries.
                //There are much more concise ways of doing this but this is the 
      clearest.
                //This is the same as previously, but with 6 boundaries instead o
      f 1.
                if( BallPointer -> X()  < - 30.0  || BallPointer -> X() > 30.0)
                {
                        BallSpeed.X( -BallSpeed.X() ) ;
                        BallBounce -> Play();
                }
                if( BallPointer -> Y()  < - 30.0  || BallPointer -> Y() > 30.0)
                {
                        BallSpeed.Y( -BallSpeed.Y() ) ;
                        BallBounce -> Play();
                }
                if( BallPointer -> Z()  < - 30.0  || BallPointer -> Z() > 30.0)
                {
                        BallSpeed.Z( -BallSpeed.Z() ) ;
                        BallBounce -> Play();
                }

        };

        void Stop()
        {

                //When this dies we want the ball to disappear.
                        _KILL(BallPointer);
                        _KILL(BallSound);

                //Stop BallPointer pointing at the model as it is killed.
                        BallPointer = 0;
                        BallSound = 0;
        };
};
\end{DoxyCode}
 \hypertarget{_code_program_examples_BulletsBouncingBallExample}{}\section{Making the camera controllable. Adding bullets.}\label{_code_program_examples_BulletsBouncingBallExample}
Lets let the mouse control the camera. Lets also allow the user to spawn bullets to shoot at the ball. We will be making new processes so I will divide it into 3 processes.
\begin{DoxyItemize}
\item The cCore process which loads files, controls the camera and spawns the other processes.
\item The cBall Process which will control the ball.
\item The cBullet Process which will control an individual bullet.
\end{DoxyItemize}
\begin{DoxyCode}
//Declare and Define a process for controlling the ball.
//class cBall : public cProcess
 _PROCESS(cBall)
 {
 public:
 //Create pointer so cCore can  access the object it creates.
 cModel *BallPointer;

 //Create a pointer so cCore can play the bounce sound.
 cAudioObject *BallBounce;

 //Create a variable for each dimension the ball moves in.
 //This could be a c3DVf which is a 3 dimensional vector
 c3DVf BallSpeed;

  //Constructor - Initialisation code.
        cBall()
        {
                //Note the media will have been loaded in cCore.
                //Since cCore will create this process
                //media will be loaded before we get to this point.
                //Create a Textured Model to put the ball on screen.
        BallPointer =  _CREATE( cModel );

                //Set the mesh it will use.
        BallPointer -> Mesh( "BallModel" );

                //Set the Texture it will use.
        BallPointer -> Texture( "BallTexture" );

                //Set the Shader it will use.
        BallPointer -> Shader( "TexturingProgram" );

                //Set a start position.
                //This is relative to the camera.
                // The first value is left and right position of the object.
                // The second value is up and down position of the object.
                // The third value is forwards and backwards.
        BallPointer -> Position( 0.0 , 0.0 , 0.0 );

                //Move the camera back 60 units so it is outside the box and look
      ing at the ball.
        _CAMERA -> Position (0.0 , 0.0 , -60);

                //Set the ball to move in a random direction at 0.1 units per fra
      me
                //RANDOM_NUMBER is a random float between 0.0 and 1.0.
                //Because this is an instance
                //(not a Bamboo engine object)
                //it should be accessed using the dot operator.

        BallSpeed.X( RANDOM_NUMBER * 0.1 );
        BallSpeed.Y( RANDOM_NUMBER * 0.1 );
        BallSpeed.Z( RANDOM_NUMBER * 0.1 );

        //Create an audio file for playing the bounce sound.
        BallBounce = _CREATE(cAudioObject);

        //Create Buffer the sound we want to play into the cAudioObject.
        BallBounce -> Buffer ( "BallSound" );

        };

        //This is the function that will update the balls position every process 
      cycle.
        void Run()
        {
                //Increase the balls speed downwards by a small amount.
                BallSpeedY = BallSpeedY - 0.01;

                //Advance the Ball by its speed in all three Global axis.
                BallPointer -> GAdvance( BallSpeed.X() , BallSpeed.Y() , BallSpee
      d.Z() );

                //If the ball is outside any of the boundaries.
                //Reverse it's direction in that axis
                if( BallPointer -> X()  < - 30.0  || BallPointer -> X() > 30.0)
                {
                        BallSpeed.X( -BallSpeed.X() ) ;
                        BallBounce -> Play();
                }
                if( BallPointer -> Y()  < - 30.0  || BallPointer -> Y() > 30.0)
                {
                        BallSpeed.Y( -BallSpeed.Y() ) ;
                        BallBounce -> Play();
                }
                if( BallPointer -> Z()  < - 30.0  || BallPointer -> Z() > 30.0)
                {
                        BallSpeed.Z( -BallSpeed.Z() ) ;
                        BallBounce -> Play();
                }

        };

        void Stop()
        {
                //When this dies we want the ball to disappear.
                _KILL(BallPointer);
                _KILL(BallSound);

                //Stop BallPointer pointing at the model as it is killed.
                BallPointer = 0;
                BallSound = 0;
        };
};

//Create a new process to be our bullets.
//class cBullet : public cProcess
_PROCESS(cBullet)
{
 public:

  //Give this a pointer to a render object.
  cPoint *RenderPoint;

  //Give this a float to count the bullets lifespan
  //This is a good idea as processes will run for ever unless limited by code.
  //Every process takes some small amount of CPU time.
  //Processes which stop having a use should be killed.
  //Some processes will want to run for ever.
  //Eventually bullets will leave the area they can do anything
  //As such it is worth considering a life span for them
  float Life;

   cBullet(cCameraMatrix4 *MatrixMatch)
   {
                //Create a point object for this object.
                RenderPoint = _CREATE( cPoint );

                //Make this start with the same transalation as the camera.
                RenderPoint -> Copy( MatrixMatch );

                //Give this point a shader to use.
                RenderPoint -> Shader( "BasicProgram" );

                //Give this bullet a life span.
                Life = 100.0;
   };

   void Run()
   {
                //Make the bullet move in the direction it is moving.
                RenderPoint -> AdvanceZ( 0.01 );

                //Reduce the bullets remaining life.
                //Eventually it will have run out of life.
                Life = Life - 0.1;

                //If the bullet has run out of life it should be killed
                if( Life < 0.0 )
                {
                        //Kill this bullet.
                        _KILL_THIS();

                        //As we know this bullet is dying we can kill the point.
                        _KILL( RenderPoint );

                        //Since RenderPoint is being killed
                        //We don't want to use its pointer any more.
                        RenderPoint = 0;
                }
   };

   void Stop()
   {
                //If something else killed this bullet RenderPoint is not dead.
                //If this bullet killed itself, RenderPoint is 0.
                //You Should not use a pointer when it is zero.
                if(RenderPoint != 0)
                {
                        //Kill RenderPoint.
                        _KILL( RenderPoint );

                        //Stop Pointing at the cPoint Object.
                        RenderPoint = 0;
                }
   };
};

 //Declare a new type of Process cCore.
//A Single instance of this process will be created
// by the engine at the start of the program.
//class cCore : public cProcess
 _PROCESS(cCore)
 {
  public:
        cCore()
        {
        //Load the imf pack with objects for demonstration 3.
        //This contains a renderable spherical mesh called BallModel.
        //This contains a texture called BallTexture.
        //This also contains a shader called TexturingProgram.
        //This also contains a bounce sound called BounceSound.
        //This also contains a second shader called BasicProgram.
                _LOAD_FILE( "Demonstration3.imf" );

        //Move the camera back 60 units so it is outside the box and looking at t
      he ball.
                _CAMERA -> Position (0.0 , 0.0 , -60);

        //Create a cBall Object.
                _CREATE(cBall);

        };

        void Run()
        {
                //Change the Yaw by the change in the mouse position.
                //Multiply by a small value to slow it down.
                        _CAMERA -> RotateY( _MOUSE->XSpeed() * 0.01 );

                //Change the Pitch by the change in the mouse position.
                //Multiply by a small value to slow it down.
                        _CAMERA -> RotateZ( _MOUSE->YSpeed() * 0.01 );

                //If the left mouse button is clicked - Fire bullets
                if( _MOUSE -> Left() )
                {
                        //Create Our bullets
                                _CREATE( cBullet( _CAMERA ) );
                }
        };

        void Stop()
        {

        };


 };
\end{DoxyCode}
 \hypertarget{_code_program_examples_CollisionsBouncingBallExample}{}\section{Example with Bullet and Ball collisions.}\label{_code_program_examples_CollisionsBouncingBallExample}
Lets add collisions so we can detect collisions between the Ball and the bullets. For now we will just kill the ball. We should also limit how fast the bullets can be fired. 
\begin{DoxyCode}
//Declare and Define a process for controlling the ball.
//class cBall : public cBall
 _PROCESS(cBall)
 {
 public:
 //Create pointer so cCore can  access the object it creates.
 cModel *BallPointer;

 //Create a pointer so cCore can play the bounce sound.
 cAudioObject *BallBounce;

 //Create a new Collision Object
 cCollisionObject *BallCollision;

 //Create a variable for each dimension the ball moves in.
 //This could be a c3DVf which is a 3 dimensional vector
 c3DVf BallSpeed;

  //Constructor - Initialisation code.
        cBall()
        {
                //Note the media will have been loaded in cCore.
                //Since cCore Creates this process media will be loaded before we
       get to this point.
                //Create a Textured Model to put the ball on screen.
        BallPointer =  _CREATE(cModel);
                //Set the mesh it will use.
        BallPointer -> Mesh( "BallModel" ) );
                //Set the Texture it will use.
        BallPointer -> Texture( _GET_MESH_FILE( "BallTexture" ) );
                //Set the Shader it will use.
        BallPointer -> Shader( _GET_SHADER_FILE( "TexturingProgram" ) );

                //Set a start position.
                //This is relative to the camera.
                // The first value is left and right position of the object.
                // The second value is up and down position of the object.
                // The third value is forwards and backwards.
                // Position it randomly between -20 and +20 on each axis.
        BallPointer -> Position( ZEROED_RANDOM_NUMBER * 20 , ZEROED_RANDOM_NUMBER
       * 20 , ZEROED_RANDOM_NUMBER * 20 );

                //Create a Collision Object to enable collisions for the Ball.
                //Have it follow the position of the Ball.
                //Have it linked to this process.
        BallCollision = _CREATE( cCollisionObject( BallPointer , this ) );

                //Set Type will set the type of collision. By handing it values i
      t will generate an object at run time.
                //A Single float will make it a sphere of the specified radius.
        BallCollision -> SetType( 1.0 );

                //We also need to set the filter value for the collision. This is
       important to maintain the speed of collision detection.
                //This means that this collision object will be checked under the
       value 1.
        BallCollision -> CollisionFilter( 1 );

                //Move the camera back 60 units so it is outside the box and look
      ing at the ball.
        _CAMERA -> Position (0.0 , 0.0 , -60);

                //Set the ball to move in a random direction at 0.1 units per fra
      me
                //RANDOM_NUMBER is a random float between 0.0 and 1.0.
                //Because this is an instance (not a Bamboo engine object) it sho
      uld be accessed using the dot operator.
        BallSpeed.X( RANDOM_NUMBER * 0.1 );
        BallSpeed.Y( RANDOM_NUMBER * 0.1 );
        BallSpeed.Z( RANDOM_NUMBER * 0.1 );

        //Create an audio file for playing the bounce sound.
        BallBounce = _CREATE(cAudioObject);
        //Create Buffer the sound we want to play into the cAudioObject.
        BallBounce -> Buffer (_GET_AUDIO_FILE( "BallSound" );

        };

        //This is the function that will update the balls position every process 
      cycle.
        void Run()
        {
                //Increase the balls speed downwards by a small amount.
                BallSpeedY = BallSpeedY - 0.01;

                        //Advance the Ball by its speed in all three Global axis.
      
                        //If this was a Local axis you would not notice a change 
      until you rotated the ball around.
                BallPointer -> GAdvance( BallSpeed.X() , BallSpeed.Y() , BallSpee
      d.Z() );

                        //If the ball is outside any of the boundaries.
                        //There are much more concise ways of doing this but this
       is the clearest.
                        //This is exactly the same as previously, but with 6 boun
      daries instead of 1.
                if( BallPointer -> X()  < - 30.0  || BallPointer -> X() > 30.0)
                {
                        BallSpeed.X( -BallSpeed.X() ) ;
                        BallBounce -> Play();
                }
                if( BallPointer -> Y()  < - 30.0  || BallPointer -> Y() > 30.0)
                {
                        BallSpeed.Y( -BallSpeed.Y() ) ;
                        BallBounce -> Play();
                }
                if( BallPointer -> Z()  < - 30.0  || BallPointer -> Z() > 30.0)
                {
                        BallSpeed.Z( -BallSpeed.Z() ) ;
                        BallBounce -> Play();
                }

        };

        void Stop()
        {
                        //When this dies we want the ball to disappear.
                _KILL(BallPointer);
                _KILL(BallSound);
                        //Stop BallPointer pointing at the model as it has been k
      illed.
                BallPointer = 0;
                BallSound = 0;
        };
};


_PROCESS(cBullet)
{
 public:
        //Create a cPoint pointer for accessing the bullet render object.
  cPoint *RenderPoint;

        //Create a cCollisionObject for bullet collisions.
  cCollisionObject *PointCollision;

   //Variable to stre the remaining lifespan of the bullet
  float Life;

   cBullet(cCameraMatrix4 *MatrixMatch)
   {
                //Create a point object for this object.
                RenderPoint = _CREATE( cPoint );

                //Make this start with the same transalation as the camera.
                RenderPoint -> Copy( MatrixMatch );

                //Give this point a shader to use.
                RenderPoint -> Shader( _GET_SHADER_FILE( "BasicProgram" ) );

                //Create a new collision object for bullet collisions.
                //Have it follow the RenderPoint (Bullet object).
                //Have it linked to this process.
                PointCollision = _CREATE( cCollisionObject( RenderPoint , this ) 
      );

                //This will set the type of collision that this collision will us
      e.
                //This will make a sphere or radius 0.5 units.
                PointCollision -> SetType ( 0.5 );

                //This Collision Filter value is different to the one for cBall.
                //This is so we can differentiate between the different collision
      s.
                PointCollision -> CollisionFilter( 2 );

                //Give this bullet a life span.
                Life = 100.0;
   };

   void Run()
   {
                //Make the bullet move in the direction it is moving.
                RenderPoint -> AdvanceZ( 0.01 );

                //Reduce the bullets remaining life. Eventually it will have run 
      out of life.
                Life = Life - 0.1;

                //If the bullet has run out of life it should be killed
                if( Life < 0.0 )
                {
                        //Kill this bullet.
                        _KILL_THIS();

                        //As we know thi bullet is dying we can kill the point.
                        _KILL( RenderPoint );

                        //Since RenderPoint is being killed we should not point a
      t it any more.
                        RenderPoint = 0;
                }

                //cProcess Pointer to use in the loop.
                cProcess *CollidingProcess;

                //cCollisionList to access the list of collisions
                cCollisionList *ListOfCollisions;

                //Generate a list of all collisions with this bullet.
                //Only check cCollisionObject s with the filter value 1.
                //I.E. Generate collisions between this bullet and any Balls.
                ListOfCollisions = PointCollision -> GenerateCollisionList( 1 );

                //This will perform this code on every collision with
                //On each loop CollidingProcess will point to
                // the process linked to each colliding object.
                _COLLISION_PROCESS_LOOP( ListOfCollisions, CollidingProcess )
                {
                        //A Bullet has hit a ball so kill the ball.
                        _KILL(CollidingProcess);
                }

                delete ListOfCollisions;
   };

   void Stop()
   {
                        //If something else has killed this bullet then RenderPoi
      nt will still be alive.
                if(RenderPoint != 0)
                {
                        //Kill RenderPoint.
                        _KILL( RenderPoint );

                        //Stop Pointing at the cPoint Object.
                        RenderPoint = 0;

                        //Notice how we do not kill PointCollision.
                        //Killing it will not break the program.
                        //cCollisionObject's a killed when their cRenderObject is
       killed.
                        //So we do not need to kill PointCollision.
                        //They can be killed separatly to their cRenderObject but
       should be killed first.
                }
   };
};

//Declare a new type of Process cCore.
//A Single instance of this process will be created
// by the engine at the start of the program.
_PROCESS(cCore)
{
public:

                //Create a float to account for reloading time on firing the bull
      ets.
        float Reload;

        cCore()
        {
        //Load the imf pack with objects for demonstration 3.
        //This contains a renderable spherical mesh called BallModel.
        //This contains a texture called BallTexture.
        //This also contains a shader called TexturingProgram.
        //This also contains a bounce sound called BounceSound.
        //This also contains a second shader called BasicProgram.
         _LOAD_FILE( "Demonstration3.imf" );

        //Move the camera back 60 units so it is outside the box and looking at t
      he ball.
        _CAMERA -> Position (0.0 , 0.0 , -60);

        //Create a cBall (Defined earlier).
         _CREATE(cBall);

        };

        void Run()
        {
                //Change the Yaw by the change in the mouse position.
                //Multiply by a small value to slow it down.
                _CAMERA -> RotateY( _MOUSE->XSpeed() * 0.01 );

                //Change the Pitch by the change in the mouse position.
                //Multiply by a small value to slow it down.
                _CAMERA -> RotateZ( _MOUSE->YSpeed() * 0.01 );

                //If the gun is not reloaded, do a bit more reloading.
                if( Reload < 10.0 ) { Reload = Reload + 0.11; }

                //If the left mouse button is pressed.
                //AND reloading is completed
                // Fire a bullet and unload the gun.
                if( _MOUSE -> Left() && Reload >= 10.0)
                {
                        //Fire a Bullet
                        //Give it the cCameraMatrix4.
                        _CREATE( cBullet( _CAMERA ) );

                        //Tell the gun it is unloaded.
                        Reload = 0.0 ;
                }
        };

        void Stop()
        {

        };


 };
\end{DoxyCode}
 \hypertarget{_code_program_examples_ReSpwaningBouncingBallExample}{}\section{Example with a continual supply of balls.}\label{_code_program_examples_ReSpwaningBouncingBallExample}
We have collisions. So lets add health to the ball. Once it runs out of health it dies. We will also have the balls respawn so you get a new target when you shoot one. Finally lets have three balls on the screen at once. 
\begin{DoxyCode}
//Declare and Define a process for controlling the ball.
//class cBall : public cProcess
 _PROCESS(cBall)
 {
 public:

        //Create pointer so cCore can  access the object it creates.
 cModel *BallPointer;

        //Create a pointer so cCore can play the bounce sound.
 cAudioObject *BallBounce;

        //Create a new Collision Object
 cCollisionObject *BallCollision;

        //Create a variable for each dimension the ball moves in.
        //This could be a c3DVf which is a 3 dimensional vector
 c3DVf BallSpeed;

        //Give this Ball a variable to store its health.
 float Health;

  //Constructor - Initialisation code.
        cBall()
        {
        //Note the media will have been loaded in cCore.
        //Since cCore Creates this process
        //Our media will be loaded before we get to this point.
        //Create a Textured Model to put the ball on screen.
                BallPointer =  _CREATE(cModel);

        //Set the mesh it will use.
                BallPointer -> Mesh( "BallModel" );

        //Set the Texture it will use.
                BallPointer -> Texture( "BallTexture" );

        //Set the Shader it will use.
                BallPointer -> Shader( "TexturingProgram" );

        //Set a start position.
        //This is relative to the global position 0.0 , 0.0 , 0.0
        // Position it randomly between -20 and +20 on each axis.
                BallPointer -> Position( ZEROED_RANDOM_NUMBER * 20 ,
                                                                 ZEROED_RANDOM_NU
      MBER * 20 ,
                                                                 ZEROED_RANDOM_NU
      MBER * 20 );

        //Create a Collision Object to enable collisions for the Ball.
        //Have it follow the position of the Ball.
        //Have it linked to this process.
                BallCollision = _CREATE( cCollisionObject( BallPointer , this ) )
      ;

        //Set Type will set the type of collision. By handing it values it will g
      enerate an object at run time.
        //A Single float will make it a sphere of the specified radius.
                BallCollision -> SetType( 1.0 );

        //We also need to set the filter value for the collision. This is importa
      nt to maintain the speed of collision detection.
        //This means that this collision object will be checked under the value 1
      .
                BallCollision -> CollisionFilter( 1 );

        //Move the camera back 60 units so it is outside the box and looking at t
      he ball.
                _CAMERA -> Position (0.0 , 0.0 , -60);

        //Set the ball to move in a random direction at 0.1 units per frame
        //RANDOM_NUMBER is a random float between 0.0 and 1.0.
        //Because this is an instance (not a Bamboo engine object) it should be a
      ccessed using the dot operator.
                BallSpeed.X( RANDOM_NUMBER * 0.1 );
                BallSpeed.Y( RANDOM_NUMBER * 0.1 );
                BallSpeed.Z( RANDOM_NUMBER * 0.1 );

        //Create an audio file for playing the bounce sound.
                BallBounce = _CREATE( cAudioObject );

        //Create Buffer the sound we want to play into the cAudioObject.
                BallBounce -> Buffer ( "BallSound" );

        //Set the health to 100 percent.
                Health = 100.0 ;

        };

        //This is the function that will update the balls position every process 
      cycle.
        void Run()
        {
                //Increase the balls speed downwards by a small amount.
                        BallSpeedY = BallSpeedY - 0.01;

                //Advance the Ball by its speed in all three Global axis.
                //If this was a Local axis you would not notice a change until yo
      u rotated the ball around.
                        BallPointer -> GAdvance( BallSpeed.X() , BallSpeed.Y() , 
      BallSpeed.Z() );

                //If the ball is outside any of the boundaries.
                //There are much more concise ways of doing this but this is the 
      clearest.
                //This is exactly the same as previously, but with 6 boundaries i
      nstead of 1.
                if( BallPointer -> X()  < - 30.0  || BallPointer -> X() > 30.0)
                {
                        BallSpeed.X( -BallSpeed.X() ) ;
                        BallBounce -> Play();
                }
                if( BallPointer -> Y()  < - 30.0  || BallPointer -> Y() > 30.0)
                {
                        BallSpeed.Y( -BallSpeed.Y() ) ;
                        BallBounce -> Play();
                }
                if( BallPointer -> Z()  < - 30.0  || BallPointer -> Z() > 30.0)
                {
                        BallSpeed.Z( -BallSpeed.Z() ) ;
                        BallBounce -> Play();
                }

        };

        void Stop()
        {
                //When this dies we want the ball to disappear.
                        _KILL(BallPointer);
                        _KILL(BallSound);

                //Stop BallPointer pointing at the model as it has been killed.
                        BallPointer = 0;
                        BallSound = 0;
        };

        //This is a Userdefined signal. see cUserSignal.
        //This allows you to send signals and information between cProcess Object
      s.
        //If you know the process type you can access member variables and functi
      ons directly.
        //Using signals allows you to contain an objects code entirely within it.
      
        void UserSignal( SIGNAL liSignal , void *lpData )
        {
                //if liSignal == 1 it indicates that a bullet has collided with t
      his processes ball.
                //We should take some damage. The amount of damage is passed thro
      ugh lpData.
                if( liSignal == 1 )
                {
                        //A bullet has collided.
                        //Deduct the Damage from the bullet from the health of th
      e ball.
                        float *Damage;
                        Damage = lpData;
                        Health = Health - Damage[0];

                        //If health is less than zero, this ball has died.
                        //Kill this ball and create a new one to replace it as a 
      target.
                        if( Health < 0 ) { _KILL_THIS(); _CREATE(cBall); }
                }

        };
};

//Create a new process type (class) cBullet.
//This will control a single bullet
//class cBullet : public cProcess
_PROCESS(cBullet)
{
 public:
        //Create a cPoint pointer for accessing the bullet render object.
  cPoint *RenderPoint;

        //Create a cCollisionObject for bullet collisions.
  cCollisionObject *PointCollision;

   //Variable to stre the remaining lifespan of the bullet
  float Life;

   cBullet(cCameraMatrix4 *MatrixMatch)
   {
                //Create a point object for this object.
                        RenderPoint = _CREATE( cPoint );

                //Make this start with the same transalation as the camera.
                        RenderPoint -> Copy( MatrixMatch );

                //Give this point a shader to use.
                        RenderPoint -> Shader( "BasicProgram" );

                //Create a new collision object for bullet collisions.
                //Have it follow the RenderPoint (Bullet object).
                //Have it linked to this process.
                        PointCollision = _CREATE( cCollisionObject( RenderPoint ,
       this ) );

                //This will set the type of collision that this collision will us
      e.
                //This will make a sphere or radius 0.5 units.
                        PointCollision -> SetType ( 0.5 );

                //This Collision Filter value is different to the one used for th
      e balls.
                //This is so we can differentiate between the different collision
      s.
                        PointCollision -> CollisionFilter( 2 );

                //Give this bullet a life span.
                        Life = 100.0;
   };

   void Run()
   {
                //Make the bullet move in the direction it is moving.
                        RenderPoint -> AdvanceZ( 0.01 );

                //Reduce the bullets remaining life. Eventually it will have run 
      out of life.
                        Life = Life - 0.1;

                //If the bullet has run out of life it should be killed
                if( Life < 0.0 )
                {
                        //Kill this bullet.
                                _KILL_THIS();

                        //As we know this bullet is dying we can kill the point.
                                _KILL( RenderPoint );

                        //Since RenderPoint is being killed we should not point a
      t it any more.
                                RenderPoint = 0;
                }

                cProcess *CollidingProcess;
                cCollisionList *ListOfCollisions;

                //Generate a list of all collisions between this bullet and Colli
      sion Objects.
                //Only cCollisionObject s with the filter value 1 will be checked
      .
                //I.E. Generate collisions between this bullet and any Balls.
                        ListOfCollisions = PointCollision -> GenerateCollisionLis
      t( 1 );

                        //This will perform this code on every collision with Col
      lidingProcess
                        //In each loop CollidingProcess will point to the process
       linked to the colliding objects.
                _COLLISION_PROCESS_LOOP( ListOfCollisions, CollidingProcess )
                {
                                //A Bullet has hit a ball so we signal the ball t
      o say it has been damaged.
                        float Damage;

                                //Generate a Random amount of damage between 0 an
      d 50.
                        Damage = RANDOM_NUMBER * 50;

                                //Signal the Ball we collided with to damage it.
                        CollidingProcess -> UserSignal( 1 , &Damage );

                                This bullet has hit a target so we kill it.
                        _KILL_THIS();
                }

                delete ListOfCollisions;
   };

   void Stop()
   {
                        //If something else has killed this bullet then RenderPoi
      nt will still be alive.
                if(RenderPoint != 0)
                {
                                //Kill RenderPoint.
                        _KILL( RenderPoint );

                                //Stop Pointing at the cPoint Object.
                        RenderPoint = 0;

                                //Notice how we do not kill PointCollision.
                                //Killing it will nto break the program,
                                //cCollisionObject s a killed when their cRenderO
      bject is killed.
                                //As such we do not need to kill it.
                                //They can be killed seperatly to their cRenderOb
      ject.
                                //A cCollisionObject should be killed before its 
      cRenderObject.
                }
   };
};

//Declare a new type of Process cCore.
//A Single instance of this process will be created
// by the engine at the start of the program.
//class cCore : public cProcess
_PROCESS(cCore)
{
public:

        //Create a float to account for reloading time on firing the bullets.
        float Reload;

        cCore()
        {
        //Load the imf pack with objects for demonstration 3.
        //This contains a renderable spherical mesh called BallModel.
        //This contains a texture called BallTexture.
        //This also contains a shader called TexturingProgram.
        //This also contains a bounce sound called BounceSound.
        //This also contains a second shader for rendering Point Objects BasicPro
      gram.
                _LOAD_FILE( "Demonstration3.imf" );

        //Move the camera back 60 units so it is outside the box.
        // The box will now be in front of the camera.
                _CAMERA -> Position (0.0 , 0.0 , -60);

        //Here we create a ball.
                _CREATE(cBall);

        //Lets create 2 more so we have three targets
                _CREATE(cBall);
                _CREATE(cBall);

        };

        void Run()
        {
                //Change the Yaw by the change in the mouse position.
                //Multiply by a small value to slow it down.
                        _CAMERA -> RotateY( _MOUSE->XSpeed() * 0.01 );

                //Change the Pitch by the change in the mouse position.
                //Multiply by a small value to slow it down.
                        _CAMERA -> RotateZ( _MOUSE->YSpeed() * 0.01 );

                //If the gun is not reloaded, do a bit more reloading.
                        if( Reload < 10.0 ) { Reload = Reload + 0.11; }

                //If the left mouse button is pressed.
                //AND reloading is completed
                // Fire a bullet and unload the gun.
                if( _MOUSE -> Left() && Reload >= 10.0)
                {
                        //Fire a Bullet
                                _CREATE(cBullet);

                        //Tell the gun it is unloaded.
                                Reload = 0.0 ;
                }
        };

        void Stop()
        {

        };


 };
\end{DoxyCode}
 \hypertarget{_code_program_examples_CompleteNoCommentsBouncingBallExample}{}\section{Previous Example without comments}\label{_code_program_examples_CompleteNoCommentsBouncingBallExample}
Same Code without comments to show amount of code required to make this simple game. 
\begin{DoxyCode}
 _PROCESS(cBall)
 {
 public:


 cModel *BallPointer;
 cAudioObject *BallBounce;
 cCollisionObject *BallCollision;
 c3DVf BallSpeed;
 float Health;

        cBall()
        {
        BallPointer =  _CREATE(cModel);
        BallPointer -> Mesh( "BallModel" );
        BallPointer -> Texture( "BallTexture" );
        BallPointer -> Shader( "TexturingProgram" );
        BallPointer -> Position( ZEROED_RANDOM_NUMBER * 20 ,
                                                         ZEROED_RANDOM_NUMBER * 2
      0 ,
                                                         ZEROED_RANDOM_NUMBER * 2
      0 );

        BallCollision = _CREATE( cCollisionObject( BallPointer , this ) );
        BallCollision -> SetType( 1.0 );
        BallCollision -> CollisionFilter( 1 );

        BallSpeed.X( RANDOM_NUMBER * 0.1 );
        BallSpeed.Y( RANDOM_NUMBER * 0.1 );
        BallSpeed.Z( RANDOM_NUMBER * 0.1 );

        BallBounce = _CREATE(cAudioObject);
        BallBounce -> Buffer ( "BallSound" );

        Health = 100.0 ;
        };

        void Run()
        {
                BallSpeedY = BallSpeedY - 0.01;

                BallPointer -> GAdvance( BallSpeed.X() , BallSpeed.Y() , BallSpee
      d.Z() );

                if( BallPointer -> X()  < - 30.0  || BallPointer -> X() > 30.0)
                {
                        BallSpeed.X( -BallSpeed.X() ) ;
                        BallBounce -> Play();
                }
                if( BallPointer -> Y()  < - 30.0  || BallPointer -> Y() > 30.0)
                {
                        BallSpeed.Y( -BallSpeed.Y() ) ;
                        BallBounce -> Play();
                }
                if( BallPointer -> Z()  < - 30.0  || BallPointer -> Z() > 30.0)
                {
                        BallSpeed.Z( -BallSpeed.Z() ) ;
                        BallBounce -> Play();
                }

        };

        void Stop()
        {

                _KILL(BallPointer);
                _KILL(BallSound);

                BallPointer = 0;
                BallSound = 0;
        };

        void UserSignal( SIGNAL liSignal , void *lpData )
        {
                if( liSignal == 1 )
                {
                        float *Damage;
                        Damage = lpData;
                        Health = Health - Damage[0];

                        if( Health < 0 ) { _KILL_THIS(); _CREATE(cBall); }
                }

        };
};


_PROCESS(cBullet)
{
 public:

  cPoint *RenderPoint;
  cCollisionObject *PointCollision;
  float Life;

   cBullet(cCameraMatrix4 *MatrixMatch)
   {
                RenderPoint = _CREATE( cPoint );
                RenderPoint -> Copy( MatrixMatch );
                RenderPoint -> Shader( "BasicProgram" );

                PointCollision = _CREATE( cCollisionObject( RenderPoint , this ) 
      );
                PointCollision -> SetType ( 0.5 );
                PointCollision -> CollisionFilter( 2 );

                Life = 100.0;
   };

   void Run()
   {

                RenderPoint -> AdvanceZ( 0.01 );
                Life = Life - 0.1;

                if( Life < 0.0 )
                {
                        _KILL_THIS();
                        _KILL( RenderPoint );
                        RenderPoint = 0;
                }

                cProcess *CollidingProcess;
                cCollisionList *ListOfCollisions;

                ListOfCollisions = PointCollision -> GenerateCollisionList( 1 );
                _COLLISION_PROCESS_LOOP( ListOfCollisions, CollidingProcess )
                {
                        float Damage;
                        Damage = RANDOM_NUMBER * 50;
                        CollidingProcess -> UserSignal( 1 , &Damage );
                        _KILL_THIS();
                }

                delete ListOfCollisions;
   };

   void Stop()
   {
                if(RenderPoint != 0)
                {
                        _KILL( RenderPoint );
                        RenderPoint = 0;
                }
   };
};


_PROCESS(cCore)
{
public:

        float Reload;

        cCore()
        {
         _LOAD_FILE( "Demonstration3.imf" );

        _CAMERA -> Position (0.0 , 0.0 , -60);


    _CREATE(cBall);
        _CREATE(cBall);
        _CREATE(cBall);

        };

        void Run()
        {
                _CAMERA -> RotateY( _MOUSE->XSpeed() * 0.01 );
                _CAMERA -> RotateZ( _MOUSE->YSpeed() * 0.01 );

                if( Reload < 10.0 ) { Reload = Reload + 0.11; }

                if( _MOUSE -> Left() && Reload >= 10.0)
                {
                        _CREATE(cBullet);
                        Reload = 0.0 ;
                }
        };

        void Stop()
        {

        };

 };
\end{DoxyCode}
 That is less than 200 lines, including spacings and empty lines. Probably less than 150 lines of code to make a simple game! 