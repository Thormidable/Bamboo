This Section is for People who have never programmed. If you have programmed in C++ before this section is not neccessary reading. C++ has been used for this game engine due to its speed and power. C and C++ are used to make drivers for hardware, applications for industry nad mnay other vital situations. It is not a comprehensive tutorial for programming by far, but it covers the basics in a simple manner to give the skills required to use Bamboo. Bamboo uses C++ and is a library which suppliers all functionality required to make simple 3D games. There are extensions and plugins being produced all the time which can increase the functionality.
\begin{DoxyEnumerate}
\item \hyperlink{_programming_basics_ProgrammingBasicsGlossary}{Glossary of Jargon}
\item \hyperlink{_programming_basics_BasicsPageStructure}{Overview C++}
\item \hyperlink{_programming_basics_BasicsPageVariables}{Variables}
\item \hyperlink{_programming_basics_BasicsPagePointers}{Pointers}
\item \hyperlink{_programming_basics_BasicsPageFunctions}{Functions}
\item \hyperlink{_programming_basics_BasicsPageOperators}{Operators}
\item \hyperlink{_programming_basics_BasicsPageMisc}{Blocks}
\item \hyperlink{_programming_basics_BasicsPageConditionals}{Conditionals}
\item \hyperlink{_programming_basics_BasicsPageLoops}{Loops}
\item \hyperlink{_programming_basics_BasicsPageClasses}{Classes}
\end{DoxyEnumerate}\hypertarget{_programming_basics_ProgrammingBasicsGlossary}{}\section{Glossary of Jargon}\label{_programming_basics_ProgrammingBasicsGlossary}
Computers only have four commands : Read a value, Write a value, Move to another line and check True/False. All the commands performed by a computer are build from these blocks. Jargon:
\begin{DoxyItemize}
\item {\bfseries Syntax} : The commands, words, symbols and grammar used to give meaning in C++.
\item {\bfseries Compiler} : A Computer program which will convert instructions in a computer language (C++) into assembly language (true computer language).
\item {\bfseries Statement} : An elementary computer instruction, which can be converted into one or more machine code instructions by a compiler.
\item {\bfseries Expression} : A Single statement to which a single answer can be calculated.
\item {\bfseries Variable} : A location in memory with a named reference.
\item {\bfseries Address} : The number representing the postition of a specific memory location.
\item {\bfseries Operator} : A symbol or group of symbols that represents a specific action. They can use the items either side to perform their action.
\item {\bfseries Function} : A already defined piece of code for performing a specific action.
\item {\bfseries Called} : When a user activates and uses a function it is known as calling a function. A function is called when it is used.
\item {\bfseries Argument} : Values which a function uses to perform its actions.
\item {\bfseries Return} Value : A Single Value which is the result of a function.
\item {\bfseries Bit} : A smallest piece of data possible. It can either be True or False. False is 0. True is 1. Everything else is also True.
\item {\bfseries Block} : Code grouped into a single unit. A Block can contain many statements.
\item {\bfseries Line} : A Single computer statement. Lines are ended with a semicolon.
\item {\bfseries Declaration} : A Statement which tells what type a varaible or function will have (Type, Return Value Type, Argument Types and Argument order).
\item {\bfseries Definition} : Defining the code which comprises a function.
\item {\bfseries Class} : A User defined variable type. This can contain both variables and functions.
\item {\bfseries Write} : Write a value into the computers memory.
\item {\bfseries Read} : Read a value from the computers memory.
\item {\bfseries User} : You
\item {\bfseries Comment} : Text to explain to humans how a program works. Is ignored by the computer.
\item {\bfseries void} : A variable with no storage capacity.
\item {\bfseries Class} : A conceptual object combining variablers and functions into a single object.
\item {\bfseries Member} : A function or variable which is stored inside a class is a member of that class. (Like humans can be members of a club or guild).
\item {\bfseries Instance} : A single copy of a class. There can be many existing copies of a particular class, each one is an Instance.
\item {\bfseries Inheritance} : Just as a child of a prent inherits their genes. A Class can inherit from another class and use its functions and properties. It can be used as the base class, but can also override functionality to make it more specific or expand on the functionality it provides.
\end{DoxyItemize}\hypertarget{_programming_basics_BasicsPageStructure}{}\section{Overview C++}\label{_programming_basics_BasicsPageStructure}
C++ is a middle level language. This means that it implies the power and speed of assembly code (literally computer language) with the usability of a high level language. In reality it is nearly as simple as a high level language and nearly as fast as as low level language. C++ is one of the most used languages in industry and academia. C++ considers case. As such each of these instances of the word 'Uppercase' are all different in C++
\begin{DoxyItemize}
\item UPPERCASE
\item UpperCase
\item uppercase
\item uPPercASe
\end{DoxyItemize}C++ Starts works from the top of the code, and works through the code one line at a time. On each line, it will follow the commands on the line, then move to the next line. It is possible for the program to move teh line the computer is on so that code is not performed in the written order. \par
 You will also notice this symbol in a lot of the examples : {\bfseries //} This symbol starts a single line comment. All text on the same text line to the right of the two slashes will be ignored by the computer. \par
 \par
 This tutorial briefly covers the major sections and covers all concepts required to use Bamboo. For further explanation or a more comprehensive study of C++ I recommend \char`\"{}The Complete Reference C++\char`\"{} by \char`\"{}Herbert Schildt\char`\"{}. It comprehensively explains all material relevant to C++ through good examples and techincal descriptions. \hypertarget{_programming_basics_BasicsPageVariables}{}\section{Variables}\label{_programming_basics_BasicsPageVariables}
A Variable is a named storage location in the computers memory. When you create a variable you give it a name. This name is used to identify the variable either to write a value to it, or read the value stored in it. This name must not start with a number but can contain both characters and numbers. \par
 \par
 Variables can be imagined as named boxes containing a single card. The value written on the card in the box is always the value stored in the variable. Only one value can be stored in a variable at any one time. When a new value is assigned to the variable, the old card is removed from the box, the new value is written on a new piece of card which is placed in the box. \par
 There are many types of variable, but the 4 main types are float, int, bool and pointers.
\begin{DoxyItemize}
\item A {\bfseries float} is a 'real' number and is a number which can have a floating (or decimal) point. It is the only type that can store fractions. Floats are also available in a range of sizes -\/ {\bfseries 32}, {\bfseries 64} and {\bfseries 80} bits. The number of bits determines how much storage space it occupys and the range it can store.
\item An {\bfseries int} (Integer) only uses 'whole' numbers, i.e. it cannot hold fractions. Integers can be signed or unsigned. Signed integers can store negative and positive values. Unsigned integers can only store 0 or positive values. Integers come in a range of sizes -\/ {\bfseries 8}, {\bfseries 16}, {\bfseries 32} and {\bfseries 64} bits. The number of bits determines how much storage space it occupys and the range it can store.
\item A {\bfseries bool} (Boolean) is a single bit.
\item A {\bfseries void} is an empty type. It cannot store any data.
\item A {\bfseries pointer} records the address location of another variable. See the section \hyperlink{_programming_basics_BasicsPagePointers}{Pointers} Pointers
\item Most of the types listed above have sub types. There are also 'classes' which can be imagined as user defined types.
\end{DoxyItemize}Declaring a variable : \par
 The line must start with the type of variable, followed by the user defined name of the variable and finishing with a semicolon. 
\begin{DoxyCode}
 //Example of C++ Grammar
 Type Variable_Name;
\end{DoxyCode}



\begin{DoxyCode}
 //Example of acceptable Variable definitions in C++

 //Declaring a new float variable of standard length called My_Float_Variable.
 float My_Float_Variable;

 //Declaring a new integer variable of standard length called My_Signed_Integer_V
      ariable.
 int My_Signed_Integer_Variable;

 //Declaring a new unsigned integer variable of standard length called My_Unsigne
      d_Integer_Variable.
 unsigned int My_Unsigned_Integer_Variable;

 //Declaring a new signed integer variable called Another_Signed_Integer_Variable
      .
 signed int Another_Signed_Integer_Variable;

 //Declaring a new boolean variable called My_Boolean.
 bool My_Boolean;

 //Declaring a new boolean variable callen Boolean02.
 bool Boolean02;


 //Example of Unacceptable declarations

 //Float cannot use the unsigned type
 unsigned float Unsigned_Float;

 //C++ Considers case. Float is different to float
 Float This_Is_Not_A_Type;

 //Must end with a semicolon
 int Must_End_With_A

 // unsigned must go before the variable type int
 int unsigned Order_Error;
\end{DoxyCode}


Variables must be declared before use so the computer knows how to access and store the data. \par


To write a value to a variable use the equals sign. The variable which will store the value goes to the left of the equals sign. The value which will be written to the variable goes to the right of the equals sign. \par
 In the box/card model, this is equivalent to writing a value on a card and putting it into a box. Remember: Each variable can hold one number at a time -\/ each box can only hold one card at a time. I.E. \par
 
\begin{DoxyCode}
 //Example C++ Code
 int Variable;
 Variable = 10;
 //Variable is now storing the value 10.
 Variable = 20;
 //Variable is now storing the value 20.
\end{DoxyCode}
\hypertarget{_programming_basics_BasicsPagePointers}{}\section{Pointers}\label{_programming_basics_BasicsPagePointers}
A pointer is a variable and stores a value. Pointer values are unsigned integer values, but the number of bits used is determined by the computer. Pointers are pointers to variables. This means that their type is a pointer to another type. The star symbol {\bfseries $\ast$} is used between the type and variable name to show it is a pointer: 
\begin{DoxyCode}
  //Example C++ Code

 //Pointer to variables of type int
 int *Int_Pointer;

 //Pointer to varaibles of type float
 float *Float_Pointer;

 //Pointer to variables of type float pointer (Points to pointers to float type v
      ariables)
 float **Pointer_To_Float_Pointers;
\end{DoxyCode}
 Every variable has an address, which is an integer value greater than 0. Pointers can store the value 0 which represents a null pointer I.E. It does not point to a variable. \par
 Variables are assigned an address when created. This cannot be chosen by the user. This represents their location in the computers memory. The variables name can be used to access it like before, but so can it's address. Pointers store the address of another variable and allow the user to access the variable through its address. The address a pointer stores can be accessed by accessing the pointer as if it was any other variable. \par
 To find the address of another variable the '\&' character should be placed before the variable name. 
\begin{DoxyCode}
 float Float_Variable;
 float *Float_Pointer;
 Float_Variable = 0;
 Float_Pointer = & Float_Variable
 // Float_Pointer is now storing the address of the variable Float_Variable.
\end{DoxyCode}
 Float\_\-Pointer is now storing the address of Float\_\-Variable. This doesn't seem very useful, but there are two important ways that pointers can be used. They can be used to pass the address of variables without copying the original. This means that completely seperate parts of the program can affect the same variable. They can also be used to access arrays. \par
 {\bfseries Arrays:} \par
 Array is a group of variables which have consecutive addresses. Arrays use this to allow you to access many variables from a single address. Variables are accessed based on their address relative to the first item in the array. An array is created and accessed using a set of square brackets {\bfseries '}\mbox{[}' Number of Variables Required {\bfseries '}\mbox{]}' . The address in the pointer is the address of the first variable. Variables in the array can be accessed based on their address relative to the first item. The first variable is 0 steps from the first variables address. The second variable is 1 step from the first variables address. And so on. To use the box / card example from earlier all the boxes are lined up in a row. They are given a number which represents their position in the line. Getting the address of the box is to get the number of that box. A Pointer can be imagined as having a big arrow which points all the way to the box with the same address as the value on the pointers card. 
\begin{DoxyCode}
 //Example of Grammar
 //Declaring Arrays
 Type ArrayName[Number_of_Variables_Required];

 //Accessing a single variable in an array
 ArrayName[Position_Of_Variable_Desired];
\end{DoxyCode}
 
\begin{DoxyCode}
 //Example of Array Use in C++
 //Create an arrray with 10 items from 0 - 9
 float My_Array_Of_10_Floats[10];

 //Assign the value 5.0 to the first float in the array
 My_Array_Of_10_Floats[0] = 5.0;

 //Assign the value 2.5 to the second float in the array
 My_Array_Of_10_Floats[1] = 2.5;

 //Assign the value 3.1 to the third float in the array
 My_Array_Of_10_Floats[2] = 3.1;

 //Assign the value 8.7 to the tenth float in the array
 My_Array_Of_10_Floats[9] = 8.7;

 float *Another_Float_Pointer;

 Another_Float_Pointer = My_Array_Of_10_Floats;

 //Assign the value 4.0 to the soxth float in the array.
 //Another_Float_Pointer and My_Array_Of_10_Floats are the same.
 Another_Float_Pointer[5] = 4.0;
\end{DoxyCode}


Pointers can also be used to access variables directly. This is done using the pointer operator. The pointer operator is composed of the dash symbol and the right pointing angled bracket {\bfseries -\/$>$} . This allows the user to access functions within variables \hyperlink{_programming_basics_BasicsPageFunctions}{Functions} Functions. Functions will be described in the next section. 
\begin{DoxyCode}
 //Example of Grammar

 //cModel is a Type of variable specific to @EngineName
 cModel New_Textured_Model;

 //There can be pointers to every type of variable
 cModel *Textured_Model_Pointer;

 //Assigning the address of New_Textured_Model to Textured_Model_Pointer.
 Textured_Model_Pointer = &New_Textured_Model;

 //Have accessed the Function Position within New_Textured_Model by using its add
      ress stored in the pointer Textured_Model_Pointer
 Textured_Model_Pointer -> Position( 0.0 , 0.0 , 0.0 );

 //This will be used later extensively. For now it is important to recognise the 
      pointer operator and where it goes.
\end{DoxyCode}
 \hypertarget{_programming_basics_BasicsPageFunctions}{}\section{Functions}\label{_programming_basics_BasicsPageFunctions}
Functions are used to perform a commonly used task. They can change variables, calculate values and perform many other tasks. \par
 A Recipe is a very good analogy for functions. You put in ingredients in the correct order. There are then a series of actions on the ingredients to turn them into the final product. A function can only result in a single product, however it does not need to have a result. The ingredients used in a recipe will affect the final result. If you are making vegetable soup, there will be a certain number of ingredients with some limitations on them. The limitations will be on what ingredients, their quality and the amount will all change the final result. However the steps of the recipe are applied and you end up with vegetable soup. If you use carrots you get carrot soup, if you use potatoes you get potatoe soup. \par
 A Function works in the same way. The 'ingredients' for a function are variables. These are called arguments of the function. When a function is defined it is given a list of acceptable arguments, this is a list of variable types. The order of the variables is important. The function applies a series of steps to the variables and can but is not required to produce a single result. The resulting value is called the return value.\par
 Functions are called by writing the function name and following it with the curved brackets () : 
\begin{DoxyCode}
 //Example of Grammar

 //Performing a function without assigning the return value
 Function_Name();

 //Assigning the return value of a function to a variable.
 Variable = Function_Name();
\end{DoxyCode}
 The functions arguments and are inserted between the curved brackets. The order and type of the arguments is very important. Functions can sometimes have several different sets of arguments. \par
 Functions can also return values in which case their result value can be used as if it were a variable. Everytime a function is used it will perform its calculations again, which means it will not neccessarilarly produce the same return value. One thing that could make a function return a different result is if one of the arguments has changed. \par


Performing Functions with Arguments: 
\begin{DoxyCode}
 //Example of Grammar

 //Performing a Function requiring three arguments and not returning a value
 Function_Name( Argument_1 , Argument_2 , Argument_3 );

 //Performing a function requiring 3 arguments and assigning the return value to 
      a variable
 Store_Return_Value = Function_Name( Argument_1 , Argument_2 , Argument_3);

 //Performing a Function without arguments or assigning the return value.
 Function_Name();

 //Performing a Function without arguments but assigning the return value to a va
      riable.
 Variable_To_Store_Return = Function_Name();
\end{DoxyCode}


You can produce your own functions. A producing a function requires two sections. A declaration and a definition. The declaration specifies the form of the function, what return type it has and what the arguments are. \par
 A function cannot be used until after it has been declared, however it can be used before it is defined. A definition without a declaration counts for both. \par
 If the function returns no value the result type is void, otherwise any type can be used. To return the value from the function use the return statement. The value returned will be the result of the function. When the return statement is called the function will immediately stop and no other code in the function will be performed. Writing Functions: 
\begin{DoxyCode}
 //Example of Grammar

 //Declaration of a Function
 Result_Type Function_Name( Argument_1_Type Argument_1_Name , Argument_2_Type Arg
      ument_2_Name , Argument_3_Type Argument_3_Name);

 //Definition of the previous Function
 Result_Type Function_Name( Argument_1_Type Argument_1_Name , Argument_2_Type Arg
      ument_2_Name , Argument_3_Type Argument_3_Name)
 {
 //Code goes here
 return Result_Value;
 };

 //Declaration of a Function with no return value.
 void Function_Name( Argument_1_Type Argument_1_Name , Argument_2_Type Argument_2
      _Name , Argument_3_Type Argument_3_Name);

 //Definition of the previous Function.
 void Function_Name( Argument_1_Type Argument_1_Name , Argument_2_Type Argument_2
      _Name , Argument_3_Type Argument_3_Name)
 {
 //Code forming the function goes here
 };

 //Declaration of a Function with no arguments but a return value
 Result_Type Function_Name();

 //Declaration of the previous Function
 Result_Type Function_Name()
 {
  //Code forming the function goes here
 return Result_Value;
 };

 //Definition of a Function with no return value or arguments.
 void Function_Name();

 //Declaration of the previous Function.
 void Function_Name()
 {
  //Code forming the function goes here
 };
\end{DoxyCode}


Writing your own functions: 
\begin{DoxyCode}
 //Example of C++ Code

 //This will create a function which will add the two values assigned to First_Va
      lue and Second_Value.
 int Add(int First_Value,int Second_Value)
 {

 //Here it returns the result which equals First_Value + Second_Value
   return First_Value+Second_Value;

 //This line will not be performed as it is after the return statement.
 First_Value = 10;
 };

 //This will calculate the length of the hypotenuse of a right angled triangle if
       given the lengths of the other two sides.
 float Hypotenuese( float Adjacent_Length , float Opposite_Length )
 {

 //Declaring variables to be used in this function.
 float Squared_Adjacent;
 float Squared_Opposite;
 float Squared_Total;

 //Calculate the squares of the other sides
 Squared_Adjacent = Adjacent_Length * Adjacent_Length;
 Squared_Opposite = Opposite_Length * Opposite_Length;

 //Calculate the square total of lengths.
 Squared_Total = Squared_Adjacent + Squared_Opposite;

 //This will return the Square Root of the square total which is the length of th
      e hypotenuse.
 return sqrt(Squared_Total);
 //Notice how another function has been called within this function.
 };
\end{DoxyCode}
 \hypertarget{_programming_basics_BasicsPageOperators}{}\section{Operators}\label{_programming_basics_BasicsPageOperators}
The Third is operators. Most people recognise some operators: {\bfseries +} ,{\bfseries -\/} ,{\bfseries $\ast$} ,{\bfseries $\backslash$} ,{\bfseries =} for plus, minus, times, divide and equals. \par
 C++ Uses many other operators but the most important ones for using Bamboo are explained here: \par
 Arithmetic operators : These are listed in the priority order the computer uses to caluclate a result. The items at the top of the list are performed before any other arithmetic operator. The order can be changed by using teh curved brackets.
\begin{DoxyItemize}
\item {\bfseries $\ast$} To muliply one value by another use the multiplication operator.
\item {\bfseries /} To divide one value by another use the divide operator. The variable to the left of the division operator is divided by the variable on the right of the division operator.
\item {\bfseries +} To add two values together use the addition operator.
\item {\bfseries -\/} To subtract one value from another use the subtraction operator. The variable to the right of the subtraction sign is subtracted from the variable on the left of the subtraction operator.
\item {\bfseries =} Assigns the value to the right of the equals sign to the variable to the left of the equals sign.
\item {\bfseries }() Curved brackets can be used to group code informing the computer to calculate the statement within the brackets and use its result.
\end{DoxyItemize}


\begin{DoxyCode}
 //The answer to this is 8 as the multiplication is done first.
 1 + 2 * 3 + 1

 //The answer to this is 12 as the statements in the brackets are done first.
 ( 1 + 2 ) * ( 3 + 1 )

 //The answer to this is 12 as the statements in the brackets are done first.
 ( 1 + 2 + 3 ) * 2

 //The answer to this is 9 as the multiplication is done first.
 1 + 2 + 3 * 2
\end{DoxyCode}

\begin{DoxyItemize}
\item {\bfseries //} Indicates a comment. Anything to the left of a // symbol on the same line as the symbol is ignored by the computer. This allows you to include explanations of how your code works.
\item {\bfseries }; Indicates the end of a line. Some code will be placed on several different lines but count as a single line of code. It is lines of code which must be terminated with this symbol. Unless specified otherwise a line should end with a ; character. 
\begin{DoxyCode}
 //Example of C++ Code showing the operators being used
 MyVariable = MyOtherVariable;
 NewVariable = 10;
 ThirdVariable = MyVariable + NewVariable;
 FinalVariable = MyVariable - 100;
\end{DoxyCode}
 \par

\end{DoxyItemize}\hypertarget{_programming_basics_BasicsPageMisc}{}\section{Blocks}\label{_programming_basics_BasicsPageMisc}
Finally there are a few other things which should be covered:
\begin{DoxyItemize}
\item Forming Blocks: \par
 C++ operates using blocks. Sections of code can be combined into a block using the curly brackets \{ \}. C++ sees code in curly brackets as a single block of code. Curly brackets automatically count as a terminated line of code. Curly brackets can be put within curly brackets. The position left and right of the brackets does not matter, but moving inner brackets further right makes it clear where different blocks start and finish. 
\begin{DoxyCode}
 //Example of Grammar
 A Simple Block
 { }

 Another Simple Block
 {

 }

 Blocks can be within other blocks
 {
  { }
  { }
 }

 //Example of a complicated Block Structure
 //Start Block 1
 {

 //Start Block 2 inside Block 1
 {

        //Start Block 3 inside Block 2
        {

                //Block 4 inside Block 3
                {}

        //Finish Block 3
        }

        //Start Block 5 inside Block 2
        {

   //Finish Block 5
        }

 //Finish Block 2
 }

 //Finish Block 1
 }
*
\end{DoxyCode}

\end{DoxyItemize}\hypertarget{_programming_basics_BasicsPageConditionals}{}\section{Conditionals}\label{_programming_basics_BasicsPageConditionals}
Conditionals are statements which depend on a statement which is either true or false. They use the conditional operators : or,and,==,$>$,$<$,$<$=,$>$= and != \par


Conditional Operators: \par
 Conditional operators are a special type of operator. They are used to determine if a statement is true or false. 0 is considered to be false. Everything else is true. If true is measured as a number it will be 1. If false will be measured as a number it will be 0. Conditional operators compare values and determine whether they meet the specified conditions and return a value of true or false. As with Arithmetic operators the conditional operators will be listed in the order of precedence from higest priority (performed first) to lowest priority.
\begin{DoxyItemize}
\item {\bfseries $>$} Will test whether the variable to the left of the angled bracket is greather than the variable to the right. 
\begin{DoxyCode}
 //This is false
 1 > 1

 //This is also false
 0 > 1

 //This is also false
 -1 > 1

 //This is true
 4 > 3

 //This is also true
 3 > -4
\end{DoxyCode}

\item {\bfseries $>$=} Will test whether the variable to the left of the angled bracket is greather than or equal to the variable to the right of the symbol. 
\begin{DoxyCode}
 //This is true
 1 >= 1

 //This is false
 0 >= 1

 //This is also false
 -1 >= 1

 //This is true
 4 >= 3

 //This is also true
 3 >= -4
\end{DoxyCode}

\item {\bfseries $<$} Will test whether the variable to the left of the angled bracket is less than the varible to the right. 
\begin{DoxyCode}
 //This is false
 1 < 1

 //This is true
 0 < 1

 //This is also true
 -1 < 1

 //This is also true
 3 < 4

 //This is false
 4 < 3
\end{DoxyCode}

\item {\bfseries $<$=} Will test whether the variable to the left of the angled bracket is less than or equal to the variable to the right of the symbol. 
\begin{DoxyCode}
 //This is true
 1 <= 1

 //This is true
 0 <= 1

 //This is also true
 -1 <= 1

 //This is false
 4 <= 3

 //This is also false
 3 <= -4
\end{DoxyCode}

\item {\bfseries ==} Will test whether two variables are equal. It will return true if they are exactly the same otherwise it will return false. Neither varible will be modified. Note it is {\bfseries two} equals symbols together. 
\begin{DoxyCode}
 //This is true
 1 == 1

 //This is false
 0 == 1

 //This is also false
 -1 == 1

 //This is also false
 3 == 4

 //This is true
 3 == 3
\end{DoxyCode}

\item {\bfseries !=} Will test whether the value of two variables are different. It will return true if their values are different. If they are exactly the same it will return false. 
\begin{DoxyCode}
 //This is false
 1 != 1

 //This is true
 0 != 1

 //This is also true
 -1 != 1

 //This is also true
 3 != 4

 //This is false
 3 != 3
\end{DoxyCode}

\item {\bfseries and} (Alternatively the \&\& operator) Will be true only if BOTH statements next to it are true. If either is false it is false. 
\begin{DoxyCode}
 //This is true
 1 == 1 and 2 == 2

 //This is false
 1 > 1 and 1 == 1

 //This is false
 0 > 1 and 3 == 3

 //This is false
 1 == 0 and 2 > 2

 //This is true
 1 == 1 && 2 > -2

 //This is false
 1 == 0 && 0 == 0
\end{DoxyCode}

\item {\bfseries or} (Alternatively the $|$$|$ operator) Will be true if EITHER statement next to it is true. If both are true it is still true. 
\begin{DoxyCode}
 //This is true
 1 == 1 or 1 == 0

 //This is true
 1 > 1 or 1 == 1

 //This is true
 2 > 1 or 3 == 3

 //This is false
 1 == 0 or 2 > 2

 //This is true
 1 == 1 || 2 > 2

 //This is false
 1 == 0 || 0 == -2
\end{DoxyCode}

\item {\bfseries !} Will invert a returned value I.E. From true to false and false to true. It is placed immediately to the left of the value to be switched. 
\begin{DoxyCode}
 //This is false
 !1

 //This is true
 !0

 //This is false
 ! 1 == 1

 //This is true
 ! 1 == 2

 //This is false
 ! 3 > -4
\end{DoxyCode}
 If else statements: The if statement allows the user to choose whether to run code. It will direct the computer to process different blocks of code depending on whether a specified conditional expression is true or false. \par
 The code can be imagined as a river. The computer drifts along the river down the page, following the commands on each line as it is reached. \par
 The if statement represents the river splitting into two streams. At the branch in the river, either the left or the right branch can be taken, but not both. The Conditional expression determines which branch in the river should be traversed. \par
 Each time the computer processes an if statement the program branches like the river. Once the code covered by the if statement has been processed the two streams rejoin to form a single main channel. The statement is given a block of code representing the path for when the conditional expression is true. It may also be given a block of code representing the path for when the conditional expression is false. There must be a block of code in the true branch of the if statement, there can be a block of code in the false branch of the if statement. Part of the if statement holds a conditional expression which is can be composed of variables, values and the conditional operators. Once the relevant branch has been completed, the computer will continue the program from immediately after the if statement. \par
 The if statement begins the conditional statement and includes the conditional expression between curved brackets. It is then followed by a block of code. This can be seen as if (Conditional statement is true) then do this block of code. After the block of code representing the path for when the conditional expression is true is the else statement. This can be seen as saying if the conditional statement is true then do the first block, else do the second block. 
\begin{DoxyCode}
 //Example of Grammar
 if ( Conditional_Statement )
 * //This is the block performed when the Conditional_Statement is true
 {  }
 //The else statement indicates that this if statement has a branch if the condit
      ional expression false branch
 else
  //This is the block performed when the Conditional_Statement is true
 {  }
\end{DoxyCode}
 Note that the if is lower case, there 
\begin{DoxyCode}
 //Example of C++ Code

 int Value;
 Value = 0;

 int Answer;
 Answer = 1;

 // Value is less than 1 so the conditional is true.
 if( Value < 1 )
 //This block is performed as the conditional is true.
 {
 //Value is set to 3.
  Value = 3;
 }
 //This is not performed as it is for when the conditional is false.
 else
 {
  Value = 2;
 }
 // At this point Value is storing the value 3.
 // This line is performed as it is after the blocks of code for the if else stat
      ement
 Answer = Value * 2 ;
 // Answer now is storing the value 6

 // Value is not less than 1 so the conditional is false.
 if( Value < 1 )
 //This block is not performed as the conditional is false.
 {
  Value = 3;
 }
 //This block is performed as the conditional is false.
 else
 {
 // Value is set to 2
  Value = 2;
 }
 // At this point Value is storing the value 2.
 // This line is performed as it is after the blocks of code for the if else stat
      ement
 Answer = Value * 2 ;
 // Answer now is storing the value 4
\end{DoxyCode}
 
\begin{DoxyCode}
 //Example of C++ Code

 //If Statement with a single block of code.
 //If Damage is greater than life then the object should be dead.
 if(Damage > Life)
 {
  //If conditional expression is true then make this dead
  MakeThisDead();
 }
\end{DoxyCode}
 
\begin{DoxyCode}
 //Example of C++ Code
 // If statement with an else section.
 if(LightShouldBeOn())
 {
 //The Light should be on.
   MakeLightOn();
 }
 else
 {
 // The Light should be off.
   MakeLightOff();
 }
\end{DoxyCode}
 
\begin{DoxyCode}
 //Example of C++ Code

 // If statement with an else section.
 int32 My_Integer;
 if(ChooseHighValue())
 {
 //Choose the Higher Value.
   My_Integer=20;
 }
 else
 {
 //Do not choose the Higher Value.
   My_Integer=10;
 }
 //The two branches both lead to here.
 // My_Integer is now either 10 or 20.
 My_Integer = 3 * My_Integer;
 //My_Integer is now either 30 or 60
\end{DoxyCode}

\end{DoxyItemize}\hypertarget{_programming_basics_BasicsPageLoops}{}\section{Loops}\label{_programming_basics_BasicsPageLoops}
Loops allow the user to perform a block of code multiple times under different conditions. This can be very useful to produce code which performs a task many times. The most commonly used loop is the for loop. The for loop contains three statements and a block of code.
\begin{DoxyItemize}
\item An Initialiser which sets the starting conditions. This statement is performed only at the start of the loop.
\item A Conditional which determines whether the block of code should be performed. The block of code is only ever run after checking the conditional.
\item A Step Statement which will change variables values each time the block of code is run. The step function is used after the block has been processed.
\end{DoxyItemize}A Step by step analysis of the operation of the for loop :
\begin{DoxyItemize}
\item The Start statement is performed.
\item The Conditional statement is checked. If true, the block of code will be processed. If the conditional is false the loop will stop and be exited.
\item The Block of code is processed.
\item The Step statement is processed to update the variables for the next repetition.
\item The loop goes back to the second item on this list. (I.E Checking the conditional statement).
\end{DoxyItemize}
\begin{DoxyCode}
 //Example of Grammar
 for(Initialiser;Condition;Step)
 {
  //This is the block of code.
 }
\end{DoxyCode}
 
\begin{DoxyCode}
 //Example of C++ Code
 //The function PrintValue will be called 100 times with values from 0 up to 99.
 //The Initialiser Statement means that Counter is 0 at the start of the loop.
 //The Conditional Statement ensures that the loop will repeat if Counter is less
       than 100.
 //After The block of code { PrintValue(Counter); } the Step function is called w
      hich will increase the value stored in Counter by 1.
 //So the block will be performed with Counter storing every value from 0 to 99 i
      n order.
 uin32 Counter;
 for(Counter=0;Counter<100;Counter=Counter+1)
 {
        PrintValue(Counter);
 }
\end{DoxyCode}
 
\begin{DoxyCode}
 //Example of C++ Code
 //The function PrintValue will be called 100 times with values from 100 down to 
      1.
 //The Initialiser Statement means that Counter is 100 at the start of the loop.
 //The Conditional Statement ensures that the loop will repeat if Counter is grea
      ter than 0.
 //After The block of code { PrintValue(Counter); } the Step function is called w
      hich will reduce the value stored in Counter by 1.
 //So the block will be performed with Counter storing every value from 100 down 
      to 1 in order.
 uint32 Counter;
 for(Counter=100;Counter>0;Counter=Counter-1)
 {
        PrintValue(Counter);
 }
\end{DoxyCode}
\hypertarget{_programming_basics_BasicsPageClasses}{}\section{Classes}\label{_programming_basics_BasicsPageClasses}
Classes are the key to C++'s true power. It is the major difference between C and C++. Classes make C++ an Object Orientated programming language. A Class is a user defined variable type. It usually contains other variables and functions. The concept of classes is very simple. A Class contains all the code and data relating to a single object in the program. By keeping the data and functions within the class they can be used without seeing the inner workings. \par
 In Bamboo almost every thing is based on a class. A Renderable Object is one which will display on the screen. As it is a class it can be controlled by using appropriate functions without having to manipulate the data manunally. A function within a class should affect the class or instance to which is belongs. The {\bfseries }. operator allows the access to variables and functions within a variable whose type is a class. 
\begin{DoxyCode}
 //Example of C++ Code
 //cModel is a Renderable object supplied by @EngineName.
 cModel My_Textured_Model;
 //Position( float , float , float) is a function within the class cModel.
 My_Textured_Model.Position( 1.0 , 1.0 , 1.0 );
 // My_Textured_Model is now Positioned at 1.0 , 1.0 , 1.0 .
\end{DoxyCode}
 Creating a copy of My\_\-Textured\_\-Model would result in having two \hyperlink{classc_model}{cModel} objects on screen. This is where the true value of the pointer symbol comes into play. By creating a pointer to an object it will allow other parts of the program to control the class without making a copy of it. A Pointer to a class allows the user to access the variables and functions within a class. 
\begin{DoxyCode}
 //Example of C++ Code
 //cModel is a Renderable object supplied by @EngineName.
 cModel My_Textured_Model;
 cModel *My_Textured_Model_Pointer;

 //Get the pointer to My_Textured_Model;
 My_Textured_Model_Pointer = &My_Textured_Model;

 //Position( float , float , float ) is within the class cModel.
 //This will position the cModel My_Textured_Model at:
 // X Co-ordinate of 1.0
 // Y Co-ordinate of 1.0
 // Z Co-ordinate of 1.0
 My_Textured_Model_Pointer -> Position( 1.0 , 1.0 , 1.0 );
\end{DoxyCode}
 The user does not need to understand the maths that positions the \hyperlink{classc_model}{cModel} at 1.0 , 1.0 , 1.0 . Thanks to classes moving and rotating Renderable Objects becomes quick and simple. \par


Creating New Classes : \par
 While using Bamboo you will need to create new class types. If you do not with to investigate the intricacies of class creation, then you can follow the basic template for Bamboo. Read this then move on to the section on using Bamboo. 
\begin{DoxyCode}
 _PROCESS( Process_Name )
 {
 public:

 Process_Name()
 {
  //Initialiser Code goes here.
  //This should _CREATE all the objects required for this process.
  //It should set their variable values etc.
  //File Loading should be carefully considered before being placed here.
  //As this code is run EVERY time an instance of this process is created.
 };

 void Stop()
 {
  //Destructor Code goes here.
  //This should send a _KILL signal to objects you wish to die when this process 
      dies.
  //This should set pointers to 0.
  //You should not use the command word delete here.
 };

 void Run()
 {
  //Code to update this process each frame goes here.
  //This should check for collisions as required.
  //Send signals to other processes.
  //Move renderable objects.
  //Play sounds.
  //etc.
 };

 };
\end{DoxyCode}
 Classes have a declaration like functions. All functions and variables in the class must be declared within the declaration of the class. Classes don't have a definition, but every function must have a definition before an instance of a class can be created. Classes have a few special functions. Classes can have Constructors and Destructors. Constructors are automatically processed any time an instance of a class is created. Destructors are automatically processed any time an instance of a class is deleted. This means that a Constructor can be used to setup a class ready to be used. A Destructor should be used to 'clean' up a class which is being deleted. The Constructor is a function with no return type (not even void) and a name which exactly matches the name of the class. It can have arguments. The Destructor is a function called Stop() with no return type (void). Stop will be called whenever a process is killed. Do not use the normal c++ destructor using the tilde key '$\sim$' as it is unpredictable about when this will occur. 
\begin{DoxyCode}
 class My_Class
 {

 public:

        // Constructor for the class My_Class.
        My_Class()
        {
        };

        // Constructor for My_Class with a single integer argument.
        // This would be called using the syntax:
        // _CREATE( My_Class( 123 ) );
        My_Class(int Integer)
        {
        };


        Define a function called Run which does not return a value.
        void Run()
        {

        };

        // Destructor for the class My_Class.
        void Stop()
        {
        };

 };
\end{DoxyCode}
 You may notice the use of the command word 'public:'. This indicates that functions and variables following the public: keyword will have the public property. There are three main states that the accessibility property of a function or variable can have in a class.
\begin{DoxyItemize}
\item {\bfseries public} : It can be accessed by any class or function in the program.
\item {\bfseries private} : It can only be accessed by the owning class.
\item {\bfseries protected} : It counts as private but can be used as public, by other classes which inherit this class.
\end{DoxyItemize}By default a class will use the property private for variables and functions. While declaring Processes in Bamboo you can make all functions and variables public.\par
 All functions and variables declared in the block of code after the classes declaration are members of the class. Each Instance of a class has a copy of all the variables. Each function will operate on the variables for the specific Instance which called it by using the dot operator ( {\bfseries }. ) or the pointer operator ({\bfseries -\/$>$} ). Bamboo owns all the instances of objects so it can update and destroy them as required. This means that within Bamboo you should only need to use the pointer operator ( {\bfseries -\/$>$} ). \par


The only other aspect of classes which is noteworthy for using Bamboo is inheritance. Inheritance means taking the variables, properties and code which compose a class an including them in a new class. The class which originally held the code is called the base class. The class which inherits the code is called the derived class. The derived class counts as a class of the base type as well as the derived type. This means a pointer to the base type can also point to an Instance of the derived type. It also means that the derived class will behave like the base class. This is how Bamboo makes Processes. All processes must inherit from the base type of \hyperlink{classc_process}{cProcess}. In the template when you type : 
\begin{DoxyCode}
 _PROCESS( Process_Name )
\end{DoxyCode}
 What it really means is you are inheriting from \hyperlink{classc_process}{cProcess}. Outside of Bamboo this would be typed 
\begin{DoxyCode}
 class Process_Name : public cProcess
\end{DoxyCode}
 This means that your process will act like all the other \hyperlink{classc_process}{cProcess} objects. Although variables and code has been inherited it can still be modified in the derived class, without affecting the Base class. This is called redefining. You can change what a version of a function does in the derived class. The function void Run() works like this. When you write code it will be different for your derived class to what it is in the base class. This is how you can create different processes which operate different ways. There are many other wonderful things about classes, but these are not critical to using Bamboo so they will not be discussed here. 