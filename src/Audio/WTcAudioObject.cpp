#include "../WTDivWin.h"

cAudioListener *cAudioListener::mpInstance=0;

cAudioListener *cAudioListener::Instance()
{
  if(!mpInstance)
    {
        mpInstance=new cAudioListener;
    }
    return mpInstance;
}

 float *cAudioListener::Position(){return spPosition;};
 float *cAudioListener::Speed(){return spSpeed;};
 float *cAudioListener::Orientation(){return spOrientation;};

void cAudioListener::Position(float lfX,float lfY,float lfZ)
{
 spPosition[0]=lfX;
 spPosition[1]=lfY;
 spPosition[2]=lfZ;
}
void cAudioListener::Speed(float lfX,float lfY,float lfZ)
{
 spSpeed[0]=lfX;
 spSpeed[1]=lfY;
 spSpeed[2]=lfZ;
}
void cAudioListener::Orientation(float lfZX,float lfZY,float lfZZ,float lfYX,float lfYY,float lfYZ)
{
 spOrientation[0]=lfZX;
 spOrientation[1]=lfZY;
 spOrientation[2]=lfZZ;
 spOrientation[3]=lfYX;
 spOrientation[4]=lfYY;
 spOrientation[5]=lfYZ;
}
void cAudioListener::Position(float *lpList)
{
    memcpy(spPosition,lpList,sizeof(float)*3);
}
void cAudioListener::Speed(float *lpList)
{
    memcpy(spSpeed,lpList,sizeof(float)*3);
}
void cAudioListener::Orientation(float *lpList)
{
    memcpy(spOrientation,lpList,sizeof(float)*6);
}

cAudioObject::cAudioObject()
{
 cAudioDevice::Instance();
 alGenSources(1, &miSource);
}

cAudioObject::cAudioObject(cAudioBuffer *lpBuffer)
{
 cAudioDevice::Instance();
 alGenSources(1, &miSource);
 mpBuffer=lpBuffer;
 alSourcei(miSource,AL_BUFFER,lpBuffer->Buffer());
}

cAudioObject::~cAudioObject()
{
 alDeleteSources(1,&miSource);
}

void cAudioObject::Play()
{
 if(Awake()) alSourcePlay(miSource);
}

void cAudioObject::SetBuffer(cAudioBuffer *lpBuffer)
{
 mpBuffer=lpBuffer;

 alSourcei(miSource,AL_BUFFER,lpBuffer->Buffer());

}

ALuint cAudioObject::Source()
{
  return miSource;

};

void cAudioObject::Signal(SIGNAL lsSignal)
{
 if( lsSignal&WT_SIGNAL_VALUE_WAKE && !mbAwake)
 {
     mbAwake=true;
 }
 if( lsSignal&WT_SIGNAL_VALUE_SLEEP && mbAwake)
 {
     Pause();
     mbAwake=false;
 }
 if( lsSignal & _S_KILL ) delete this;

};

void cAudioObject::Stop()
{
    alSourceStop(miSource);
}

void cAudioObject::Pause()
{
    alSourcePause(miSource);
}

void cAudioObject::Position(float lfX,float lfY,float lfZ)
{
      mpPosition[0]=lfX;
      mpPosition[1]=lfY;
      mpPosition[2]=lfZ;
      alSourcefv(miSource, AL_POSITION, mpPosition);
};

  void cAudioObject::Speed(float lfX,float lfY,float lfZ)
  {
      mpSpeed[0]=lfX;
      mpSpeed[0]=lfY;
      mpSpeed[0]=lfZ;
      alSourcefv(miSource, AL_VELOCITY, mpSpeed);
  };



  void cAudioObject::Loop(bool lbLoop){mbLooping=lbLoop; alSourcei(miSource, AL_LOOPING, mbLooping);};
  float *cAudioObject::Position(){return mpPosition;};
  float *cAudioObject::Speed(){return mpSpeed;};
  bool cAudioObject::Loop(){return mbLooping;};
  void cAudioObject::Gain(float lfGain){mfGain=lfGain;          alSourcef(miSource, AL_GAIN, mfGain);};
  void cAudioObject::Pitch(float lfPitch){mfPitch=lfPitch;   	alSourcef(miSource, AL_PITCH, mfPitch);};
  float cAudioObject::Gain(){return mfGain;};
  float cAudioObject::Pitch(){return mfPitch;};

/*
    	alSourcef(source[0], AL_PITCH, 1.0f);
    	alSourcef(source[0], AL_GAIN, 1.0f);
    	alSourcefv(source[0], AL_POSITION, source0Pos);
    	alSourcefv(source[0], AL_VELOCITY, source0Vel);
    	alSourcei(source[0], AL_BUFFER,buffer[0]);
    	alSourcei(source[0], AL_LOOPING, AL_TRUE);


     	alListenerfv(AL_POSITION,listenerPos);
    	alListenerfv(AL_VELOCITY,listenerVel);
    	alListenerfv(AL_ORIENTATION,listenerOri);

    	alSourceQueueBuffers
    	alSourceUnqueueBuffers

    	void alDopplerFactor(ALfloat dopplerFactor);
        void alSpeedOfSound(ALfloat speed);

alSourcePlayv, alSourcePause, alSourcePausev, alSourceRewind, alSourceRewindv, alSourceStop, alSourceStopv


Source Properties
Each source generated by alGenSources has properties which can be set or retrieved. The alSource[f, 3f, fv, i] and alGetSource[f, 3f, fv, i] families of functions can be used to set or retrieve the following source properties:
Property
Data Type
Description
AL_PITCH
f, fv
pitch multiplier
always positive
AL_GAIN
f, fv
source gain
value should be positive
AL_MAX_DISTANCE
f, fv, i, iv
used with the Inverse Clamped Distance Model to set the distance where there will no longer be any attenuation of the source
AL_ROLLOFF_FACTOR
f, fv, i, iv
the rolloff rate for the source
default is 1.0
AL_REFERENCE_DISTANCE
f, fv, i, iv
the distance under which the volume for the source would normally drop by half (before being influenced by rolloff factor or AL_MAX_DISTANCE)
AL_MIN_GAIN
f, fv
the minimum gain for this source
AL_MAX_GAIN
f, fv
the maximum gain for this source
AL_CONE_OUTER_GAIN
f, fv
the gain when outside the oriented cone
AL_CONE_INNER_ANGLE
f, fv, i, iv
the gain when inside the oriented cone
AL_CONE_OUTER_ANGLE
f, fv, i, iv
outer angle of the sound cone, in degrees
default is 360
AL_POSITION
fv, 3f
X, Y, Z position
AL_VELOCITY
fv, 3f
velocity vector
AL_DIRECTION
fv, 3f, iv, 3i
direction vector
AL_SOURCE_RELATIVE
i, iv
determines if the positions are relative to the listener
default is AL_FALSE
AL_SOURCE_TYPE
i, iv
the soruce type – AL_UNDETERMINED, AL_STATIC, or AL_STREAMING
AL_LOOPING
i, iv
turns looping on (AL_TRUE) or off (AL_FALSE)
AL_BUFFER
i, iv
the ID of the attached buffer
AL_SOURCE_STATE
i, iv
the state of the source (AL_STOPPED, AL_PLAYING, …)
AL_BUFFERS_QUEUED*
i, iv
the number of buffers queued on this source
AL_BUFFERS_PROCESSED*
i, iv
the number of buffers in the queue that have been processed
AL_SEC_OFFSET
f, fv, i, iv
the playback position, expressed in seconds
AL_SAMPLE_OFFSET
f, fv, i, iv
the playback position, expressed in samples
AL_BYTE_OFFSET
f, fv, i, iv
the playback position, expressed in bytes
    	*/
