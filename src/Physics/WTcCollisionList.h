#ifndef __WTCCOLLISIONLIST_H__
#define __WTCCOLLISIONLIST_H__

/**
 * \brief This will form a single object in the List owned by a cCollisionList. It will store all the important data about a single collision.
 * Currently all the important data is the other cCollisionBase involved in the collision and the relative distance between teh two objects.
 * This means that the list can be generated (very slow) and then is cached to allow sorting or other user controls on filtering, Without having to test collisions again.
 * */
class cCollisionListObject
{

public:
	cCollisionBase *mpObj;
	float mfDistance;
	float mfBeamLength;
	c3DVf mvCentre;

	cCollisionListObject(cCollisionBase *lpObj);
	cCollisionListObject();
	float Distance();
	float BeamLength();
	///This will Recalculate the Distances from the base object as this cannot be determined when the collision is detected.
	void RecalculateDistance(cCollisionBase *lpThis);
	///This will return the centre of the Collision.
	c3DVf Centre();
};

/**
 * \brief This is generated by doing Collision Detection with an object.
 * This will cache all the detected collisions with the object used for the collision detection. This allows the user to access the collisions in a different order to the order they were detected or to cache it for use later.
 * The list is composed of a list of cCollisionListObject.
 *
 * */

class cCollisionList : public  cLimitedPointerList<cCollisionListObject>
{
 friend class cCollisionListObject;
int32 miCurPos;


public:
    cCollisionBase *mpThisColl;
    static cCollisionBase *mpOther;
    static cCollisionList *mpStaticList;

	///The Constructor for cCollisionList
cCollisionList(cCollisionBase *lpThisColl);
///This will Add the object lpObject to the list of objects colliding with the current searching object.
void AddCollision(cCollisionBase *lpObject);

///This will Add the cCollisionListObject to the list.
void AddCollision(cCollisionListObject *lpObj);

///This will Create a new cCollisionListObject and add it to the list, using mpOther as the Object.
void AddCollision();

///This will return the next cCollisionListObject from this list with details of the collision.
cCollisionListObject *NextCollisionDetail();

cCollisionListObject *CurrentCollisionDetail();

///This will return the next item from the list mpCollisionList that has been stocked by GenerateCollisionList() as a CollisionObject pointer.
cCollisionBase *NextCollisionItem();

cCollisionBase *CurrentCollisionItem();

///This will return the process owning renderable object creating the next detected collision.
cProcess *NextCollisionP();

cProcess *CurrentCollisionP();

///This will return the renderable object involved in the next detected collision.
vRenderObject *NextCollisionR();

vRenderObject *CurrentCollisionR();

///This is the destructor for cCollisionList
~cCollisionList();
///This will sort the list of collisionobjects by distance from the colliding object order. This allows the user to resolve the collisions in 'Chronological' order.
void SortByDistance();

///This will sort the list of collisionobjects by Beam Lengths. If the object used for the search is used, it is Beam length alopng this object, otherwise it is the Beam length of the other object (if it is a beam) This allows the user to resolve the collisions in 'Chronological' order.
void SortByBeamLength();

void RecalculateDistances();

///This will reset the Cursor back to the start of the list.
void ResetCursor();

///This will Set the Cursor to the specified position in the list.
void SetCursorPosition(int32 liCursorPos);

static bool CompareDistances(cCollisionListObject *lp1,cCollisionListObject *lp2);
static bool CompareBeamLengths(cCollisionListObject *lp1,cCollisionListObject *lp2);


};

#endif
